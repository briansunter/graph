;; Analyzed by ClojureScript 1.10.773
{:rename-macros {}, :renames {}, :externs {setTimeout {}, process {hrtime {}}, Java {type {}}, Object {out {println {}}, error {println {}}}}, :use-macros {}, :excludes #{}, :name cljs.core, :imports {StringBuffer goog.string.StringBuffer}, :requires {gstring goog.string, goog.string goog.string, goog.Uri goog.Uri, garray goog.array, goog.object goog.object, goog.math.Integer goog.math.Integer, StringBuffer goog.string.StringBuffer, gobject goog.object, goog.array goog.array, goog.math.Long goog.math.Long}, :uses nil, :defs {->PersistentHashSet {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 27, :column 10, :factory :positional, :line 9161, :end-line 9161, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :doc "Positional factory function for cljs.core/PersistentHashSet."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentHashSet, :file "cljs/core.cljs", :end-column 27, :method-params ([meta hash-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 9161, :ret-tag cljs.core/PersistentHashSet, :end-line 9161, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :doc "Positional factory function for cljs.core/PersistentHashSet."}, js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10767, :column 7, :end-line 10767, :end-column 14, :arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[x]], :arglists ([x] [x & opts]), :arglists-meta (nil nil)}}, :name cljs.core/js->clj, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[x]], :arglists ([x] [x & opts]), :arglists-meta (nil nil)}, :method-params [[x]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 1, :variadic? true, :tag #{nil clj any cljs.core/MapEntry}}], :line 10767, :end-line 10767, :max-fixed-arity 1, :fn-var true, :arglists ([x] [x & opts]), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords."}, sort-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2463, :column 7, :end-line 2463, :end-column 14, :arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[keyfn coll] [keyfn comp coll]], :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort-by, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[keyfn coll] [keyfn comp coll]], :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}, :method-params [[keyfn coll] [keyfn comp coll]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag #{seq cljs.core/IList}}], :line 2463, :end-line 2463, :max-fixed-arity 3, :fn-var true, :arglists ([keyfn coll] [keyfn comp coll]), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ITransientAssociative {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 35, :column 14, :line 806, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :end-line 806, :sigs {:-assoc! {:name -assoc!, :arglists ([tcoll key val]), :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."}}, :doc "Protocol for adding associativity to transient collections.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ITransientAssociative, :file "cljs/core.cljs", :end-column 35, :column 1, :line 806, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :info nil, :end-line 806, :tag any, :sigs {:-assoc! {:name -assoc!, :arglists ([tcoll key val]), :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."}}, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding associativity to transient collections.", :jsdoc ("@interface")}, chunk-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3645, :column 7, :end-line 3645, :end-column 18, :arglists (quote ([s]))}, :name cljs.core/chunk-first, :file "cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3645, :ret-tag any, :end-line 3645, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, print-meta? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10102, :column 7, :end-line 10102, :end-column 18, :arglists (quote ([opts obj]))}, :name cljs.core/print-meta?, :file "cljs/core.cljs", :end-column 18, :method-params ([opts obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10102, :ret-tag boolean, :end-line 10102, :max-fixed-arity 2, :fn-var true, :arglists (quote ([opts obj]))}, m3-hash-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 942, :column 15, :end-line 942, :end-column 26, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-int, :file "cljs/core.cljs", :end-column 26, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 942, :ret-tag number, :end-line 942, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, pr-str* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 890, :column 7, :end-line 890, :end-column 14, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, :name cljs.core/pr-str*, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 890, :ret-tag string, :end-line 890, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, eduction {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10702, :column 7, :end-line 10702, :end-column 15, :arglists (quote ([xform* coll])), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}}, :name cljs.core/eduction, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}, :method-params [(xforms)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag cljs.core/Eduction}], :line 10702, :ret-tag any, :end-line 10702, :max-fixed-arity 0, :fn-var true, :arglists ([& xforms]), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called."}, tree-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5201, :column 7, :end-line 5201, :end-column 15, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree."}, :name cljs.core/tree-seq, :file "cljs/core.cljs", :end-column 15, :method-params ([branch? children root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5201, :ret-tag cljs.core/LazySeq, :end-line 5201, :max-fixed-arity 3, :fn-var true, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree."}, unchecked-remainder-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2790, :column 7, :end-line 2790, :end-column 30, :arglists (quote ([x n]))}, :name cljs.core/unchecked-remainder-int, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2790, :ret-tag number, :end-line 2790, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n]))}, uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11299, :column 7, :end-line 11299, :end-column 11, :arglists (quote ([s]))}, :name cljs.core/uuid, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11299, :ret-tag cljs.core/UUID, :end-line 11299, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1226, :column 12, :end-line 1226, :end-column 15, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, :name cljs.core/seq, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1226, :ret-tag seq, :end-line 1226, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, Volatile {:num-fields 1, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/Volatile, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 4574, :record false, :end-line 4574, :tag function, :skip-protocol-flag #{cljs.core/IDeref}}, reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2520, :column 7, :end-line 2520, :end-column 13, :arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[f coll] [f val coll]], :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :name cljs.core/reduce, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[f coll] [f val coll]], :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params [[f coll] [f val coll]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag #{nil any}} {:fixed-arity 3, :variadic? false, :tag #{nil any}}], :line 2520, :end-line 2520, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll]), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called."}, IUUID {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 19, :column 14, :line 11271, :protocol-info {:methods {}}, :end-line 11271, :sigs {}, :doc "A marker protocol for UUIDs", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IUUID, :file "cljs/core.cljs", :end-column 19, :column 1, :line 11271, :protocol-info {:methods {}}, :info nil, :end-line 11271, :tag any, :sigs {}, :impls #{cljs.core/UUID}, :doc "A marker protocol for UUIDs", :jsdoc ("@interface")}, INIT {:name cljs.core/INIT, :file "cljs/core.cljs", :line 4047, :column 1, :end-line 4047, :end-column 10, :meta {:file "cljs/core.cljs", :line 4047, :column 6, :end-line 4047, :end-column 10}, :tag object}, find-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11664, :column 7, :end-line 11664, :end-column 14, :arglists (quote ([ns])), :doc "Returns the namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only."}, :name cljs.core/find-ns, :file "cljs/core.cljs", :end-column 14, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11664, :ret-tag #{cljs.core/Namespace any clj-nil}, :end-line 11664, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns])), :doc "Returns the namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only."}, contains? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2352, :column 7, :end-line 2352, :end-column 16, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, :name cljs.core/contains?, :file "cljs/core.cljs", :end-column 16, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2352, :ret-tag boolean, :end-line 2352, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4234, :column 7, :end-line 4234, :end-column 13, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, :name cljs.core/every?, :file "cljs/core.cljs", :end-column 13, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4234, :ret-tag boolean, :end-line 4234, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, ->ES6IteratorSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/ISeq cljs.core/ISeqable}, :file "cljs/core.cljs", :end-column 24, :column 10, :factory :positional, :line 1319, :end-line 1319, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :doc "Positional factory function for cljs.core/ES6IteratorSeq."}, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/->ES6IteratorSeq, :file "cljs/core.cljs", :end-column 24, :method-params ([value iter _rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 1319, :ret-tag cljs.core/ES6IteratorSeq, :end-line 1319, :max-fixed-arity 3, :fn-var true, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :doc "Positional factory function for cljs.core/ES6IteratorSeq."}, Var {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :name cljs.core/Var, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 1131, :record false, :end-line 1131, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}}, keep-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4596, :column 7, :end-line 4596, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f coll]], :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep-indexed, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f coll]], :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params [[f] [f coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false}], :line 4596, :end-line 4596, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided."}, ->PersistentQueueSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :file "cljs/core.cljs", :end-column 28, :column 10, :factory :positional, :line 6206, :end-line 6206, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/PersistentQueueSeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueueSeq, :file "cljs/core.cljs", :end-column 28, :method-params ([meta front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6206, :ret-tag cljs.core/PersistentQueueSeq, :end-line 6206, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/PersistentQueueSeq."}, subs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2986, :column 7, :end-line 2986, :end-column 11, :arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[s start] [s start end]], :arglists ([s start] [s start end]), :arglists-meta (nil nil)}}, :name cljs.core/subs, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[s start] [s start end]], :arglists ([s start] [s start end]), :arglists-meta (nil nil)}, :method-params [[s start] [s start end]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag string} {:fixed-arity 3, :variadic? false, :tag string}], :line 2986, :end-line 2986, :max-fixed-arity 3, :fn-var true, :arglists ([s start] [s start end]), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive."}, js-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 538, :column 7, :end-line 538, :end-column 17, :arglists (quote ([x])), :doc "Returns true if x is an instance of Symbol"}, :name cljs.core/js-symbol?, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 538, :ret-tag boolean, :end-line 538, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is an instance of Symbol"}, IFind {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 19, :column 14, :line 647, :protocol-info {:methods {-find [[coll k]]}}, :end-line 647, :sigs {:-find {:name -find, :arglists ([coll k]), :doc "Returns the map entry for key, or nil if key not present."}}, :doc "Protocol for implementing entry finding in collections.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IFind, :file "cljs/core.cljs", :end-column 19, :column 1, :line 647, :protocol-info {:methods {-find [[coll k]]}}, :info nil, :end-line 647, :tag any, :sigs {:-find {:name -find, :arglists ([coll k]), :doc "Returns the map entry for key, or nil if key not present."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :doc "Protocol for implementing entry finding in collections.", :jsdoc ("@interface")}, set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9429, :column 7, :end-line 9429, :end-column 10, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, :name cljs.core/set, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9429, :ret-tag #{clj any cljs.core/ISet cljs.core/MetaFn clj-nil}, :end-line 9429, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, MODULE_URIS {:name cljs.core/MODULE_URIS, :file "cljs/core.cljs", :line 39, :column 1, :end-line 39, :end-column 17, :meta {:file "cljs/core.cljs", :line 39, :column 6, :end-line 39, :end-column 17}, :tag clj-nil}, compare-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2417, :column 17, :end-line 2417, :end-column 32, :private true, :arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection.", :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[xs ys] [xs ys len n]], :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/compare-indexed, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[xs ys] [xs ys len n]], :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}, :method-params [[xs ys] [xs ys len n]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag #{any number}} {:fixed-arity 4, :variadic? false, :tag number}], :line 2417, :end-line 2417, :max-fixed-arity 4, :fn-var true, :arglists ([xs ys] [xs ys len n]), :doc "Compare indexed collection."}, take-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4814, :column 7, :end-line 4814, :end-column 16, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, :name cljs.core/take-last, :file "cljs/core.cljs", :end-column 16, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4814, :ret-tag seq, :end-line 4814, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, IndexedSeq {:meta {:file "cljs/core.cljs", :line 1201, :column 29, :end-line 1201, :end-column 39, :declared true}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/IndexedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 1585, :record false, :declared true, :end-line 1585, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, bit-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2901, :column 7, :end-line 2901, :end-column 14, :arglists (quote ([x n])), :doc "Set bit at index n"}, :name cljs.core/bit-set, :file "cljs/core.cljs", :end-column 14, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2901, :ret-tag number, :end-line 2901, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Set bit at index n"}, string-hash-cache-count {:name cljs.core/string-hash-cache-count, :file "cljs/core.cljs", :line 969, :column 1, :end-line 969, :end-column 29, :meta {:file "cljs/core.cljs", :line 969, :column 6, :end-line 969, :end-column 29}, :tag number}, qualified-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3400, :column 7, :end-line 3400, :end-column 25, :arglists (quote ([x])), :doc "Return true if x is a keyword with a namespace"}, :name cljs.core/qualified-keyword?, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3400, :ret-tag boolean, :end-line 3400, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a keyword with a namespace"}, ->Eduction {:protocol-inline nil, :meta {:protocols #{cljs.core/Object cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 18, :column 10, :factory :positional, :line 10672, :end-line 10672, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Eduction."}, :protocols #{cljs.core/Object cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->Eduction, :file "cljs/core.cljs", :end-column 18, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 10672, :ret-tag cljs.core/Eduction, :end-line 10672, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Eduction."}, tree-map-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8637, :column 8, :end-line 8637, :end-column 20, :private true, :arglists (quote ([comp tree k v found]))}, :private true, :name cljs.core/tree-map-add, :file "cljs/core.cljs", :end-column 20, :method-params ([comp tree k v found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8637, :ret-tag #{any clj-nil cljs.core/RedNode}, :end-line 8637, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree k v found]))}, ->ES6SetEntriesIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 31, :column 10, :factory :positional, :line 6558, :end-line 6558, :arglists (quote ([s])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ES6SetEntriesIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6SetEntriesIterator, :file "cljs/core.cljs", :end-column 31, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6558, :ret-tag cljs.core/ES6SetEntriesIterator, :end-line 6558, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ES6SetEntriesIterator."}, -with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 699, :column 9, :end-line 699, :end-column 19, :tag clj, :protocol cljs.core/IWithMeta, :doc "Returns a new object with value of o and metadata meta added to it.", :arglists (quote ([o meta]))}, :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :file "cljs/core.cljs", :end-column 19, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 697, :ret-tag clj, :end-line 699, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([o meta])), :doc "Returns a new object with value of o and metadata meta added to it."}, reset-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10979, :column 8, :end-line 10979, :end-column 19, :private true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, :private true, :name cljs.core/reset-cache, :file "cljs/core.cljs", :end-column 19, :method-params ([method-cache method-table cached-hierarchy hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10979, :ret-tag #{nil any}, :end-line 10979, :max-fixed-arity 4, :fn-var true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, ->PersistentArrayMapIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 36, :column 10, :factory :positional, :line 6820, :end-line 6820, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/PersistentArrayMapIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentArrayMapIterator, :file "cljs/core.cljs", :end-column 36, :method-params ([arr i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6820, :ret-tag cljs.core/PersistentArrayMapIterator, :end-line 6820, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/PersistentArrayMapIterator."}, PersistentArrayMapIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/PersistentArrayMapIterator, :file "cljs/core.cljs", :end-column 36, :type true, :column 10, :line 6820, :record false, :end-line 6820, :tag function, :skip-protocol-flag nil}, butlast {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9509, :column 7, :end-line 9509, :end-column 14, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, :name cljs.core/butlast, :file "cljs/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9509, :ret-tag seq, :end-line 9509, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, tail-off {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5374, :column 8, :end-line 5374, :end-column 16, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/tail-off, :file "cljs/core.cljs", :end-column 16, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5374, :ret-tag number, :end-line 5374, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, unchecked-subtract-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2800, :column 15, :end-line 2800, :end-column 37, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract-int, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag number} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2800, :ret-tag number, :end-line 2800, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 880, :column 4, :end-line 880, :end-column 13, :protocol cljs.core/IIterable, :doc "Returns an iterator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IIterable, :name cljs.core/-iterator, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 878, :ret-tag any, :end-line 880, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an iterator for coll."}, *print-namespace-maps* {:meta {:file "cljs/core.cljs", :line 144, :column 3, :end-line 144, :end-column 25, :dynamic true, :doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, :name cljs.core/*print-namespace-maps*, :file "cljs/core.cljs", :end-column 25, :column 1, :dynamic true, :line 138, :end-line 144, :tag any, :doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, take-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9825, :column 7, :end-line 9825, :end-column 15, :arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[n] [n coll]], :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-nth, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[n] [n coll]], :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params [[n] [n coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 9825, :end-line 9825, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided."}, first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1253, :column 7, :end-line 1253, :end-column 12, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, :name cljs.core/first, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1253, :ret-tag #{any clj-nil}, :end-line 1253, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, native-satisfies? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 286, :column 7, :end-line 286, :end-column 24, :arglists (quote ([p x])), :doc "Internal - do not use!"}, :name cljs.core/native-satisfies?, :file "cljs/core.cljs", :end-column 24, :method-params ([p x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 286, :ret-tag boolean, :end-line 286, :max-fixed-arity 2, :fn-var true, :arglists (quote ([p x])), :doc "Internal - do not use!"}, seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2246, :column 7, :end-line 2246, :end-column 11, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, :name cljs.core/seq?, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2246, :ret-tag boolean, :end-line 2246, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, -global-hierarchy {:meta {:file "cljs/core.cljs", :line 10869, :column 3, :end-line 10869, :end-column 20, :private true, :jsdoc ["@type {*}"]}, :private true, :name cljs.core/-global-hierarchy, :file "cljs/core.cljs", :end-column 20, :column 1, :line 10866, :end-line 10869, :tag clj-nil, :jsdoc ["@type {*}"]}, UUID {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable cljs.core/IUUID}, :name cljs.core/UUID, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 11273, :record false, :end-line 11273, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, -sorted-seq-from {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 751, :column 9, :end-line 751, :end-column 25, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists (quote ([coll k ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :file "cljs/core.cljs", :end-column 25, :method-params ([coll k ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 746, :ret-tag clj, :end-line 751, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)"}, println-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10289, :column 7, :end-line 10289, :end-column 18, :arglists (quote ([& objs])), :doc "println to a string, returning it", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println-str, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag string}], :line 10289, :ret-tag any, :end-line 10289, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "println to a string, returning it"}, inst-ms {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1410, :column 7, :end-line 1410, :end-column 14, :arglists (quote ([inst])), :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT"}, :name cljs.core/inst-ms, :file "cljs/core.cljs", :end-column 14, :method-params ([inst]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1410, :ret-tag any, :end-line 1410, :max-fixed-arity 1, :fn-var true, :arglists (quote ([inst])), :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT"}, linear-traversal-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1849, :column 8, :end-line 1849, :end-column 28, :private true, :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll n] [coll n not-found]], :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/linear-traversal-nth, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll n] [coll n not-found]], :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params [[coll n] [coll n not-found]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag #{any clj-nil}} {:fixed-arity 3, :variadic? false, :tag #{nil any clj-nil}}], :line 1849, :end-line 1849, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found])}, iterate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5097, :column 7, :end-line 5097, :end-column 14, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :added "1.0"}, :added "1.0", :name cljs.core/iterate, :file "cljs/core.cljs", :end-column 14, :method-params ([f x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5097, :ret-tag cljs.core/Iterate, :end-line 5097, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"}, checked-aget' {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 486, :column 8, :end-line 486, :end-column 21, :private true, :arglists (quote ([array idx] [array idx & idxs])), :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[array idx]], :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/checked-aget', :file "cljs/core.cljs", :end-column 21, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[array idx]], :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}, :method-params [[array idx]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 2, :variadic? true, :tag any}], :line 486, :end-line 486, :max-fixed-arity 2, :fn-var true, :arglists ([array idx] [array idx & idxs])}, -empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 590, :column 4, :end-line 590, :end-column 10, :protocol cljs.core/IEmptyableCollection, :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists (quote ([coll]))}, :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 588, :ret-tag any, :end-line 590, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty."}, newline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10244, :column 7, :end-line 10244, :end-column 14, :arglists (quote ([] [opts])), :doc "Prints a newline using *print-fn*", :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [opts]], :arglists ([] [opts]), :arglists-meta (nil nil)}}, :name cljs.core/newline, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [opts]], :arglists ([] [opts]), :arglists-meta (nil nil)}, :method-params [[] [opts]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 0, :variadic? false, :tag any} {:fixed-arity 1, :variadic? false, :tag clj-nil}], :line 10244, :end-line 10244, :max-fixed-arity 1, :fn-var true, :arglists ([] [opts]), :doc "Prints a newline using *print-fn*"}, ILookup {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 21, :column 14, :line 632, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :end-line 632, :sigs {:-lookup {:name -lookup, :arglists ([o k] [o k not-found]), :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."}}, :doc "Protocol for looking up a value in a data structure.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ILookup, :file "cljs/core.cljs", :end-column 21, :column 1, :line 632, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :info nil, :end-line 632, :tag any, :sigs {:-lookup {:name -lookup, :arglists ([o k] [o k not-found]), :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/TransientHashMap cljs.core/TaggedLiteral cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}, :doc "Protocol for looking up a value in a data structure.", :jsdoc ("@interface")}, -chunked-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 844, :column 4, :end-line 844, :end-column 17, :protocol cljs.core/IChunkedSeq, :doc "Return a new collection of coll with the first chunk removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 840, :ret-tag any, :end-line 844, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new collection of coll with the first chunk removed."}, write-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10070, :column 7, :end-line 10070, :end-column 16, :arglists (quote ([writer & ss])), :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}}, :name cljs.core/write-all, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}, :method-params [(writer ss)], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? true, :tag clj-nil}], :line 10070, :ret-tag any, :end-line 10070, :max-fixed-arity 1, :fn-var true, :arglists ([writer & ss])}, fn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2024, :column 7, :end-line 2024, :end-column 10, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, :name cljs.core/fn?, :file "cljs/core.cljs", :end-column 10, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2024, :ret-tag boolean, :end-line 2024, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, -prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11038, :column 4, :end-line 11038, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val dispatch-val-y]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11034, :ret-tag any, :end-line 11038, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val dispatch-val-y])), :doc nil}, -assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 643, :column 9, :end-line 643, :end-column 15, :tag clj, :protocol cljs.core/IAssociative, :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists (quote ([coll k v]))}, :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :file "cljs/core.cljs", :end-column 15, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 638, :ret-tag clj, :end-line 643, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k v])), :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it."}, doall {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9966, :column 7, :end-line 9966, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [n coll]], :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/doall, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [n coll]], :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params [[coll] [n coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false}], :line 9966, :end-line 9966, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time."}, keyword-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3351, :column 7, :end-line 3351, :end-column 25, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, :name cljs.core/keyword-identical?, :file "cljs/core.cljs", :end-column 25, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3351, :ret-tag boolean, :end-line 3351, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, *print-err-fn* {:meta {:file "cljs/core.cljs", :line 90, :column 3, :end-line 90, :end-column 17, :doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed.", :dynamic true}, :name cljs.core/*print-err-fn*, :file "cljs/core.cljs", :end-column 17, :column 1, :dynamic true, :line 86, :end-line 90, :tag any, :doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed."}, pv-aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5368, :column 8, :end-line 5368, :end-column 15, :private true, :arglists (quote ([node idx val]))}, :private true, :name cljs.core/pv-aset, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5368, :ret-tag any, :end-line 5368, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node idx val]))}, prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11258, :column 7, :end-line 11258, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, :name cljs.core/prefers, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11258, :ret-tag any, :end-line 11258, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, -js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10765, :column 4, :end-line 10765, :end-column 12, :protocol cljs.core/IEncodeClojure, :doc "Transforms JavaScript values to Clojure", :arglists (quote ([x options]))}, :protocol cljs.core/IEncodeClojure, :name cljs.core/-js->clj, :file "cljs/core.cljs", :end-column 12, :method-params ([x options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10764, :ret-tag any, :end-line 10765, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x options])), :doc "Transforms JavaScript values to Clojure"}, LazySeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/LazySeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3429, :record false, :end-line 3429, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, dedupe {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10645, :column 7, :end-line 10645, :end-column 13, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [coll]], :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/dedupe, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [coll]], :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params [[] [coll]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 0, :variadic? false, :tag function} {:fixed-arity 1, :variadic? false, :tag clj}], :line 10645, :end-line 10645, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided."}, unchecked-editable-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6040, :column 8, :end-line 6040, :end-column 36, :private true, :arglists (quote ([tv i]))}, :private true, :name cljs.core/unchecked-editable-array-for, :file "cljs/core.cljs", :end-column 36, :method-params ([tv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6040, :ret-tag any, :end-line 6040, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tv i]))}, ->ES6Iterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 21, :column 10, :factory :positional, :line 1305, :end-line 1305, :arglists (quote ([s])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ES6Iterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6Iterator, :file "cljs/core.cljs", :end-column 21, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 1305, :ret-tag cljs.core/ES6Iterator, :end-line 1305, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ES6Iterator."}, VectorNode {:num-fields 2, :protocols #{}, :name cljs.core/VectorNode, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5360, :record false, :end-line 5360, :tag function, :skip-protocol-flag nil}, dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2010, :column 7, :end-line 2010, :end-column 13, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [coll k]], :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/dissoc, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [coll k]], :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params [[coll] [coll k]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag #{clj clj-nil}} {:fixed-arity 2, :variadic? true, :tag #{clj clj-nil}}], :line 2010, :end-line 2010, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s)."}, atom {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4460, :column 7, :end-line 4460, :end-column 11, :arglists (quote ([x] [x & {:keys [meta validator]}])), :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[x]], :arglists ([x] [x & {:keys [meta validator]}]), :arglists-meta (nil nil)}}, :name cljs.core/atom, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[x]], :arglists ([x] [x & {:keys [meta validator]}]), :arglists-meta (nil nil)}, :method-params [[x]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag cljs.core/Atom} {:fixed-arity 1, :variadic? true, :tag cljs.core/Atom}], :line 4460, :end-line 4460, :max-fixed-arity 1, :fn-var true, :arglists ([x] [x & {:keys [meta validator]}]), :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change."}, bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2915, :column 7, :end-line 2915, :end-column 22, :arglists (quote ([x n])), :doc "Bitwise shift right"}, :name cljs.core/bit-shift-right, :file "cljs/core.cljs", :end-column 22, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2915, :ret-tag number, :end-line 2915, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right"}, MapEntry {:meta {:file "cljs/core.cljs", :line 1991, :column 47, :end-line 1991, :end-column 55, :declared true}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/MapEntry, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 6649, :record false, :declared true, :end-line 6649, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, *clojurescript-version* {:name cljs.core/*clojurescript-version*, :file "cljs/core.cljs", :line 19, :column 1, :end-line 19, :end-column 29, :meta {:file "cljs/core.cljs", :line 19, :column 6, :end-line 19, :end-column 29}, :tag string}, -first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 616, :column 4, :end-line 616, :end-column 10, :protocol cljs.core/ISeq, :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-first, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 614, :ret-tag any, :end-line 616, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection coll. Used by cljs.core/first."}, peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2098, :column 7, :end-line 2098, :end-column 11, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, :name cljs.core/peek, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2098, :ret-tag #{any clj-nil}, :end-line 2098, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, IKVReduce {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 23, :column 14, :line 710, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :end-line 710, :sigs {:-kv-reduce {:name -kv-reduce, :arglists ([coll f init]), :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."}}, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IKVReduce, :file "cljs/core.cljs", :end-column 23, :column 1, :line 710, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :info nil, :end-line 710, :tag any, :sigs {:-kv-reduce {:name -kv-reduce, :arglists ([coll f init]), :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap}, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :jsdoc ("@interface")}, iter-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2497, :column 8, :end-line 2497, :end-column 19, :private true, :arglists (quote ([coll f] [coll f init])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll f] [coll f init]], :arglists ([coll f] [coll f init]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/iter-reduce, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll f] [coll f init]], :arglists ([coll f] [coll f init]), :arglists-meta (nil nil)}, :method-params [[coll f] [coll f init]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag #{nil any}}], :line 2497, :end-line 2497, :max-fixed-arity 3, :fn-var true, :arglists ([coll f] [coll f init])}, aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 502, :column 7, :end-line 502, :end-column 11, :arglists (quote ([array idx] [array idx & idxs])), :doc "Returns the value at the index/indices. Works on JavaScript arrays.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[array idx]], :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}}, :name cljs.core/aget, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[array idx]], :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}, :method-params [[array idx]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 2, :variadic? true, :tag any}], :line 502, :end-line 502, :max-fixed-arity 2, :fn-var true, :arglists ([array idx] [array idx & idxs]), :doc "Returns the value at the index/indices. Works on JavaScript arrays."}, PersistentTreeMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentTreeMapSeq, :file "cljs/core.cljs", :end-column 30, :type true, :column 10, :line 8174, :record false, :end-line 8174, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -write {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 765, :column 4, :end-line 765, :end-column 10, :protocol cljs.core/IWriter, :doc "Writes s with writer and returns the result.", :arglists (quote ([writer s]))}, :protocol cljs.core/IWriter, :name cljs.core/-write, :file "cljs/core.cljs", :end-column 10, :method-params ([writer s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 763, :ret-tag any, :end-line 765, :max-fixed-arity 2, :fn-var true, :arglists (quote ([writer s])), :doc "Writes s with writer and returns the result."}, iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4071, :column 7, :end-line 4071, :end-column 11, :arglists (quote ([coll]))}, :name cljs.core/iter, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4071, :ret-tag #{clj any}, :end-line 4071, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, mk-bound-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9617, :column 7, :end-line 9617, :end-column 18, :arglists (quote ([sc test key]))}, :name cljs.core/mk-bound-fn, :file "cljs/core.cljs", :end-column 18, :method-params ([sc test key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9617, :ret-tag function, :end-line 9617, :max-fixed-arity 3, :fn-var true, :arglists (quote ([sc test key]))}, last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1782, :column 7, :end-line 1782, :end-column 11, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, :name cljs.core/last, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1782, :ret-tag #{any clj-nil}, :end-line 1782, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, -default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11042, :column 4, :end-line 11042, :end-column 25, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-default-dispatch-val, :file "cljs/core.cljs", :end-column 25, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11034, :ret-tag any, :end-line 11042, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, pr {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10262, :column 7, :end-line 10262, :end-column 9, :arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr, :file "cljs/core.cljs", :end-column 9, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag clj-nil}], :line 10262, :ret-tag any, :end-line 10262, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader"}, tree-map-seq-push {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8167, :column 8, :end-line 8167, :end-column 25, :private true, :arglists (quote ([node stack ascending?]))}, :private true, :name cljs.core/tree-map-seq-push, :file "cljs/core.cljs", :end-column 25, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8167, :end-line 8167, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?]))}, namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3369, :column 7, :end-line 3369, :end-column 16, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, :name cljs.core/namespace, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3369, :ret-tag #{string clj-nil}, :end-line 3369, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, empty-unordered-hash {:name cljs.core/empty-unordered-hash, :file "cljs/core.cljs", :line 1377, :column 1, :end-line 1377, :end-column 36, :private true, :meta {:file "cljs/core.cljs", :line 1377, :column 16, :end-line 1377, :end-column 36, :private true}, :tag number}, obj-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8919, :column 7, :end-line 8919, :end-column 14, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/obj-map, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag any}], :line 8919, :ret-tag any, :end-line 8919, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new object map with supplied mappings."}, Reduced {:num-fields 1, :protocols #{cljs.core/IDeref}, :name cljs.core/Reduced, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 1443, :record false, :end-line 1443, :tag function, :skip-protocol-flag #{cljs.core/IDeref}}, -conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 596, :column 9, :end-line 596, :end-column 14, :tag clj, :protocol cljs.core/ICollection, :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists (quote ([coll o]))}, :protocol cljs.core/ICollection, :name cljs.core/-conj, :file "cljs/core.cljs", :end-column 14, :method-params ([coll o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 594, :ret-tag clj, :end-line 596, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll o])), :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)"}, NodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/NodeSeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7709, :record false, :end-line 7709, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, = {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1286, :column 16, :end-line 1286, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/=, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? true, :tag boolean}], :line 1286, :ret-tag boolean, :end-line 1286, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison."}, ITransientMap {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 27, :column 14, :line 812, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :end-line 812, :sigs {:-dissoc! {:name -dissoc!, :arglists ([tcoll key]), :doc "Returns a new transient collection of tcoll without the mapping for key."}}, :doc "Protocol for adding mapping functionality to transient collections.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ITransientMap, :file "cljs/core.cljs", :end-column 27, :column 1, :line 812, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :info nil, :end-line 812, :tag any, :sigs {:-dissoc! {:name -dissoc!, :arglists ([tcoll key]), :doc "Returns a new transient collection of tcoll without the mapping for key."}}, :impls #{cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding mapping functionality to transient collections.", :jsdoc ("@interface")}, push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5390, :column 8, :end-line 5390, :end-column 17, :private true, :arglists (quote ([pv level parent tailnode]))}, :private true, :name cljs.core/push-tail, :file "cljs/core.cljs", :end-column 17, :method-params ([pv level parent tailnode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5390, :ret-tag cljs.core/VectorNode, :end-line 5390, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pv level parent tailnode]))}, take {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4757, :column 7, :end-line 4757, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[n] [n coll]], :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[n] [n coll]], :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params [[n] [n coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 4757, :end-line 4757, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided."}, vector? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2179, :column 7, :end-line 2179, :end-column 14, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, :name cljs.core/vector?, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2179, :ret-tag boolean, :end-line 2179, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, array-index-of-equiv? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6608, :column 8, :end-line 6608, :end-column 29, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-equiv?, :file "cljs/core.cljs", :end-column 29, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6608, :ret-tag number, :end-line 6608, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, bitmap-indexed-node-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7171, :column 8, :end-line 7171, :end-column 33, :private true, :arglists (quote ([bitmap bit]))}, :private true, :name cljs.core/bitmap-indexed-node-index, :file "cljs/core.cljs", :end-column 33, :method-params ([bitmap bit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 7171, :ret-tag number, :end-line 7171, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bitmap bit]))}, boolean {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2262, :column 7, :end-line 2262, :end-column 14, :arglists (quote ([x])), :doc "Coerce to boolean"}, :name cljs.core/boolean, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2262, :ret-tag boolean, :end-line 2262, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to boolean"}, IChunk {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 20, :column 14, :line 835, :protocol-info {:methods {-drop-first [[coll]]}}, :end-line 835, :sigs {:-drop-first {:name -drop-first, :arglists ([coll]), :doc "Return a new chunk of coll with the first item removed."}}, :doc "Protocol for accessing the items of a chunk.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IChunk, :file "cljs/core.cljs", :end-column 20, :column 1, :line 835, :protocol-info {:methods {-drop-first [[coll]]}}, :info nil, :end-line 835, :tag any, :sigs {:-drop-first {:name -drop-first, :arglists ([coll]), :doc "Return a new chunk of coll with the first item removed."}}, :impls #{cljs.core/RangeChunk cljs.core/ArrayChunk}, :doc "Protocol for accessing the items of a chunk.", :jsdoc ("@interface")}, bit-shift-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2911, :column 7, :end-line 2911, :end-column 21, :arglists (quote ([x n])), :doc "Bitwise shift left"}, :name cljs.core/bit-shift-left, :file "cljs/core.cljs", :end-column 21, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2911, :ret-tag number, :end-line 2911, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift left"}, random-uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11303, :column 7, :end-line 11303, :end-column 18, :arglists (quote ([]))}, :name cljs.core/random-uuid, :file "cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11303, :end-line 11303, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, any? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 281, :column 7, :end-line 281, :end-column 11, :arglists (quote ([x])), :doc "Returns true if given any argument."}, :name cljs.core/any?, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 281, :ret-tag boolean, :end-line 281, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if given any argument."}, rand-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10839, :column 7, :end-line 10839, :end-column 15, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, :name cljs.core/rand-int, :file "cljs/core.cljs", :end-column 15, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10839, :ret-tag any, :end-line 10839, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, aclone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 432, :column 7, :end-line 432, :end-column 13, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, :name cljs.core/aclone, :file "cljs/core.cljs", :end-column 13, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 432, :ret-tag array, :end-line 432, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, BlackNode {:meta {:file "cljs/core.cljs", :line 8248, :column 18, :end-line 8248, :end-column 27, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/BlackNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 8348, :record false, :declared true, :end-line 8348, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4591, :column 7, :end-line 4591, :end-column 14, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, :name cljs.core/vreset!, :file "cljs/core.cljs", :end-column 14, :method-params ([vol newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4591, :ret-tag any, :end-line 4591, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3642, :column 7, :end-line 3642, :end-column 12, :arglists (quote ([b]))}, :name cljs.core/chunk, :file "cljs/core.cljs", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3642, :ret-tag any, :end-line 3642, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, UNREALIZED-SEED {:name cljs.core/UNREALIZED-SEED, :file "cljs/core.cljs", :line 5036, :column 1, :end-line 5036, :end-column 31, :private true, :meta {:file "cljs/core.cljs", :line 5036, :column 16, :end-line 5036, :end-column 31, :private true}, :tag object}, dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2693, :column 7, :end-line 2693, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one less than num."}, :name cljs.core/dec, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2693, :ret-tag number, :end-line 2693, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than num."}, ->TransformerIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 29, :column 10, :factory :positional, :line 4153, :end-line 4153, :arglists (quote ([buffer _next completed xf sourceIter multi])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/TransformerIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->TransformerIterator, :file "cljs/core.cljs", :end-column 29, :method-params ([buffer _next completed xf sourceIter multi]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4153, :ret-tag cljs.core/TransformerIterator, :end-line 4153, :max-fixed-arity 6, :fn-var true, :arglists (quote ([buffer _next completed xf sourceIter multi])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/TransformerIterator."}, APersistentVector {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 31, :column 14, :line 5495, :protocol-info {:methods {}}, :end-line 5495, :sigs {}, :doc "Marker protocol", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/APersistentVector, :file "cljs/core.cljs", :end-column 31, :column 1, :line 5495, :protocol-info {:methods {}}, :info nil, :end-line 5495, :tag any, :sigs {}, :impls #{cljs.core/PersistentVector}, :doc "Marker protocol", :jsdoc ("@interface")}, map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4710, :column 7, :end-line 4710, :end-column 10, :arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[f] [f coll] [f c1 c2] [f c1 c2 c3]], :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/map, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[f] [f coll] [f c1 c2] [f c1 c2 c3]], :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}, :method-params [[f] [f coll] [f c1 c2] [f c1 c2 c3]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 3, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 4, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 4, :variadic? true, :tag cljs.core/LazySeq}], :line 4710, :end-line 4710, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided."}, juxt {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9917, :column 7, :end-line 9917, :end-column 11, :arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[f] [f g] [f g h]], :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/juxt, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[f] [f g] [f g h]], :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}, :method-params [[f] [f g] [f g h]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag function} {:fixed-arity 3, :variadic? false, :tag function} {:fixed-arity 3, :variadic? true, :tag function}], :line 9917, :end-line 9917, :max-fixed-arity 3, :fn-var true, :arglists ([f] [f g] [f g h] [f g h & fs]), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]"}, ->PersistentQueueIter {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 29, :column 10, :factory :positional, :line 6191, :end-line 6191, :arglists (quote ([fseq riter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/PersistentQueueIter."}, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentQueueIter, :file "cljs/core.cljs", :end-column 29, :method-params ([fseq riter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6191, :ret-tag cljs.core/PersistentQueueIter, :end-line 6191, :max-fixed-arity 2, :fn-var true, :arglists (quote ([fseq riter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/PersistentQueueIter."}, < {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2645, :column 16, :end-line 2645, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? true, :tag boolean}], :line 2645, :ret-tag boolean, :end-line 2645, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false."}, *eval* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11736, :column 3, :end-line 11736, :end-column 9, :doc "Runtime environments may provide a way to evaluate ClojureScript\n  forms. Whatever function *eval* is bound to will be passed any forms which\n  should be evaluated.", :dynamic true}, :name cljs.core/*eval*, :file "cljs/core.cljs", :end-column 9, :method-params ([_]), :protocol-impl nil, :arglists-meta (), :column 1, :variadic? false, :dynamic true, :line 11732, :ret-tag ignore, :end-line 11736, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Runtime environments may provide a way to evaluate ClojureScript\n  forms. Whatever function *eval* is bound to will be passed any forms which\n  should be evaluated."}, inode-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7188, :column 8, :end-line 7188, :end-column 23, :private true, :arglists (quote ([arr f init]))}, :private true, :name cljs.core/inode-kv-reduce, :file "cljs/core.cljs", :end-column 23, :method-params ([arr f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 7188, :ret-tag #{nil cljs.core/Reduced}, :end-line 7188, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr f init]))}, obj-map->hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6388, :column 8, :end-line 6388, :end-column 25, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/obj-map->hash-map, :file "cljs/core.cljs", :end-column 25, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6388, :ret-tag clj, :end-line 6388, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11404, :column 7, :end-line 11404, :end-column 11, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, :name cljs.core/test, :file "cljs/core.cljs", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11404, :ret-tag cljs.core/Keyword, :end-line 11404, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1264, :column 12, :end-line 1264, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, :name cljs.core/rest, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1264, :ret-tag seq, :end-line 1264, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, ex-data {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11368, :column 7, :end-line 11368, :end-column 14, :arglists (quote ([ex])), :doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-data, :file "cljs/core.cljs", :end-column 14, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11368, :ret-tag #{any clj-nil}, :end-line 11368, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, PersistentArrayMapSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentArrayMapSeq, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 6749, :record false, :end-line 6749, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -drop-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 837, :column 4, :end-line 837, :end-column 15, :protocol cljs.core/IChunk, :doc "Return a new chunk of coll with the first item removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 835, :ret-tag any, :end-line 837, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new chunk of coll with the first item removed."}, isa? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10879, :column 16, :end-line 10879, :end-column 20, :tag boolean, :arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[child parent] [h child parent]], :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}}, :name cljs.core/isa?, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[child parent] [h child parent]], :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}, :method-params [[child parent] [h child parent]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag boolean} {:fixed-arity 3, :variadic? false, :tag boolean}], :line 10879, :ret-tag boolean, :end-line 10879, :max-fixed-arity 3, :tag boolean, :fn-var true, :arglists ([child parent] [h child parent]), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy"}, boolean? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2237, :column 7, :end-line 2237, :end-column 15, :arglists (quote ([x])), :doc "Return true if x is a Boolean"}, :name cljs.core/boolean?, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2237, :ret-tag boolean, :end-line 2237, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Boolean"}, -clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 580, :column 9, :end-line 580, :end-column 15, :tag clj, :protocol cljs.core/ICloneable, :doc "Creates a clone of value.", :arglists (quote ([value]))}, :protocol cljs.core/ICloneable, :name cljs.core/-clone, :file "cljs/core.cljs", :end-column 15, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 578, :ret-tag clj, :end-line 580, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([value])), :doc "Creates a clone of value."}, munge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11513, :column 7, :end-line 11513, :end-column 12, :arglists (quote ([name]))}, :name cljs.core/munge, :file "cljs/core.cljs", :end-column 12, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11513, :ret-tag #{any string cljs.core/Symbol}, :end-line 11513, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, empty-ordered-hash {:name cljs.core/empty-ordered-hash, :file "cljs/core.cljs", :line 1362, :column 1, :end-line 1362, :end-column 34, :private true, :meta {:file "cljs/core.cljs", :line 1362, :column 16, :end-line 1362, :end-column 34, :private true}, :tag number}, DEMUNGE_MAP {:name cljs.core/DEMUNGE_MAP, :file "cljs/core.cljs", :line 368, :column 1, :end-line 369, :end-column 14, :jsdoc ["@enum {string}"], :meta {:file "cljs/core.cljs", :line 369, :column 3, :end-line 369, :end-column 14, :jsdoc ["@enum {string}"]}, :tag object}, ES6IteratorSeq {:num-fields 3, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/ES6IteratorSeq, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 1319, :record false, :end-line 1319, :tag function, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, ->NeverEquiv {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/Object}, :file "cljs/core.cljs", :end-column 20, :column 10, :factory :positional, :line 6337, :end-line 6337, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}, :doc "Positional factory function for cljs.core/NeverEquiv."}, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/->NeverEquiv, :file "cljs/core.cljs", :end-column 20, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6337, :ret-tag cljs.core/NeverEquiv, :end-line 6337, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}, :doc "Positional factory function for cljs.core/NeverEquiv."}, re-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10027, :column 7, :end-line 10027, :end-column 13, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, :name cljs.core/re-seq, :file "cljs/core.cljs", :end-column 13, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10027, :ret-tag #{clj clj-nil}, :end-line 10027, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, char? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 276, :column 7, :end-line 276, :end-column 12, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string of length one."}, :name cljs.core/char?, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 276, :ret-tag boolean, :end-line 276, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string of length one."}, make-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10862, :column 7, :end-line 10862, :end-column 21, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, :name cljs.core/make-hierarchy, :file "cljs/core.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10862, :ret-tag cljs.core/IMap, :end-line 10862, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, Symbol {:meta {:file "cljs/core.cljs", :line 965, :column 15, :end-line 965, :end-column 21, :declared true}, :num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/Symbol, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 1073, :record false, :declared true, :end-line 1073, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, PROTOCOL_SENTINEL {:name cljs.core/PROTOCOL_SENTINEL, :file "cljs/core.cljs", :line 37, :column 1, :end-line 37, :end-column 27, :meta {:file "cljs/core.cljs", :line 37, :column 10, :end-line 37, :end-column 27}, :tag object}, tv-push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6014, :column 8, :end-line 6014, :end-column 20, :private true, :arglists (quote ([tv level parent tail-node]))}, :private true, :name cljs.core/tv-push-tail, :file "cljs/core.cljs", :end-column 20, :method-params ([tv level parent tail-node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6014, :ret-tag #{nil cljs.core/VectorNode}, :end-line 6014, :max-fixed-arity 4, :fn-var true, :arglists (quote ([tv level parent tail-node]))}, -reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 705, :column 4, :end-line 705, :end-column 11, :protocol cljs.core/IReduce, :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists (quote ([coll f] [coll f start])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll f] [coll f start]], :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}}, :protocol cljs.core/IReduce, :name cljs.core/-reduce, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll f] [coll f start]], :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}, :method-params [[coll f] [coll f start]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag any}], :line 702, :end-line 705, :max-fixed-arity 3, :fn-var true, :arglists ([coll f] [coll f start]), :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."}, -count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 585, :column 12, :end-line 585, :end-column 18, :tag number, :protocol cljs.core/ICounted, :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists (quote ([coll]))}, :protocol cljs.core/ICounted, :name cljs.core/-count, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 583, :ret-tag number, :end-line 585, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Calculates the count of coll in constant time. Used by cljs.core/count."}, swap-vals! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4532, :column 7, :end-line 4532, :end-column 17, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :added "1.9", :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[a f] [a f x] [a f x y]], :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}}, :added "1.9", :name cljs.core/swap-vals!, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[a f] [a f x] [a f x y]], :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}, :method-params [[a f] [a f x] [a f x y]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag cljs.core/IVector} {:fixed-arity 3, :variadic? false, :tag cljs.core/IVector} {:fixed-arity 4, :variadic? false, :tag cljs.core/IVector} {:fixed-arity 4, :variadic? true, :tag cljs.core/IVector}], :line 4532, :end-line 4532, :max-fixed-arity 4, :fn-var true, :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap."}, keep {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4397, :column 7, :end-line 4397, :end-column 11, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f coll]], :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f coll]], :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params [[f] [f coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 4397, :end-line 4397, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided."}, char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2713, :column 7, :end-line 2713, :end-column 11, :arglists (quote ([x])), :doc "Coerce to char"}, :name cljs.core/char, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2713, :ret-tag #{nil js/String}, :end-line 2713, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to char"}, mapcat {:protocol-inline nil, :meta {:added "1.0", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[f]], :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :column 7, :line 5154, :end-line 5154, :arglists (quote ([f] [f & colls])), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, :added "1.0", :name cljs.core/mapcat, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[f]], :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :method-params [[f]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 1, :variadic? true, :tag any}], :line 5154, :end-line 5154, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & colls]), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, unchecked-long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2827, :column 7, :end-line 2827, :end-column 21, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/unchecked-long, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2827, :ret-tag number, :end-line 2827, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, m3-seed {:name cljs.core/m3-seed, :file "cljs/core.cljs", :line 923, :column 1, :end-line 923, :end-column 13, :meta {:file "cljs/core.cljs", :line 923, :column 6, :end-line 923, :end-column 13}, :tag number}, some? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 260, :column 16, :end-line 260, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, :name cljs.core/some?, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 260, :ret-tag boolean, :end-line 260, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, unchecked-negate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2782, :column 7, :end-line 2782, :end-column 23, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2782, :ret-tag number, :end-line 2782, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, remove-tap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11562, :column 7, :end-line 11562, :end-column 17, :arglists (quote ([f])), :doc "Remove f from the tap set."}, :name cljs.core/remove-tap, :file "cljs/core.cljs", :end-column 17, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11562, :ret-tag clj-nil, :end-line 11562, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Remove f from the tap set."}, symbol-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3360, :column 7, :end-line 3360, :end-column 24, :arglists (quote ([x y])), :doc "Efficient test to determine that two symbols are identical."}, :name cljs.core/symbol-identical?, :file "cljs/core.cljs", :end-column 24, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3360, :ret-tag boolean, :end-line 3360, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two symbols are identical."}, *command-line-args* {:name cljs.core/*command-line-args*, :file "cljs/core.cljs", :line 306, :column 1, :end-line 309, :end-column 22, :doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied", :meta {:file "cljs/core.cljs", :line 309, :column 3, :end-line 309, :end-column 22, :doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}, :tag clj-nil}, reverse {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3211, :column 7, :end-line 3211, :end-column 14, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, :name cljs.core/reverse, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3211, :ret-tag #{nil seq cljs.core/IList any}, :end-line 3211, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, inst? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1415, :column 7, :end-line 1415, :end-column 12, :arglists (quote ([x])), :doc "Return true if x satisfies Inst"}, :name cljs.core/inst?, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1415, :ret-tag boolean, :end-line 1415, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies Inst"}, range {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9801, :column 7, :end-line 9801, :end-column 12, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[] [end] [start end] [start end step]], :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/range, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[] [end] [start end] [start end step]], :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}, :method-params [[] [end] [start end] [start end step]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 0, :variadic? false, :tag any} {:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag clj}], :line 9801, :end-line 9801, :max-fixed-arity 3, :fn-var true, :arglists ([] [end] [start end] [start end step]), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity."}, bit-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2927, :column 7, :end-line 2927, :end-column 16, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, :name cljs.core/bit-count, :file "cljs/core.cljs", :end-column 16, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2927, :ret-tag number, :end-line 2927, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, create-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7691, :column 8, :end-line 7691, :end-column 19, :private true, :arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :top-fn {:variadic? false, :fixed-arity 7, :max-fixed-arity 7, :method-params [[shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]], :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-node, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic? false, :fixed-arity 7, :max-fixed-arity 7, :method-params [[shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]], :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}, :method-params [[shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]], :protocol-impl nil, :fixed-arity 7, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 6, :variadic? false, :tag #{any cljs.core/HashCollisionNode}} {:fixed-arity 7, :variadic? false, :tag #{any cljs.core/HashCollisionNode}}], :line 7691, :end-line 7691, :max-fixed-arity 7, :fn-var true, :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])}, sort {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2449, :column 7, :end-line 2449, :end-column 11, :arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [comp coll]], :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [comp coll]], :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}, :method-params [[coll] [comp coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag #{seq cljs.core/IList}}], :line 2449, :end-line 2449, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [comp coll]), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ->MetaFn {:protocol-inline nil, :meta {:protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :file "cljs/core.cljs", :end-column 16, :column 10, :factory :positional, :line 2029, :end-line 2029, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/MetaFn."}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/->MetaFn, :file "cljs/core.cljs", :end-column 16, :method-params ([afn meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 2029, :ret-tag cljs.core/MetaFn, :end-line 2029, :max-fixed-arity 2, :fn-var true, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/MetaFn."}, unchecked-inc-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2765, :column 7, :end-line 2765, :end-column 24, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc-int, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2765, :ret-tag number, :end-line 2765, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 831, :column 12, :end-line 831, :end-column 20, :tag number, :protocol cljs.core/IComparable, :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists (quote ([x y]))}, :protocol cljs.core/IComparable, :name cljs.core/-compare, :file "cljs/core.cljs", :end-column 20, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 829, :ret-tag number, :end-line 831, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y."}, map-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4369, :column 7, :end-line 4369, :end-column 18, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f coll]], :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/map-indexed, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f coll]], :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params [[f] [f coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false}], :line 4369, :end-line 4369, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided."}, array-list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9564, :column 7, :end-line 9564, :end-column 17, :arglists (quote ([]))}, :name cljs.core/array-list, :file "cljs/core.cljs", :end-column 17, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9564, :ret-tag cljs.core/ArrayList, :end-line 9564, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, rand-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10843, :column 7, :end-line 10843, :end-column 15, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, :name cljs.core/rand-nth, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10843, :ret-tag #{any clj-nil}, :end-line 10843, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, comp {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4286, :column 7, :end-line 4286, :end-column 11, :arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[] [f] [f g] [f g h]], :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/comp, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[] [f] [f g] [f g h]], :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}, :method-params [[] [f] [f g] [f g h]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag function} {:fixed-arity 3, :variadic? false, :tag function} {:fixed-arity 3, :variadic? true, :tag function}], :line 4286, :end-line 4286, :max-fixed-arity 3, :fn-var true, :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc."}, array-chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3553, :column 7, :end-line 3553, :end-column 18, :arglists (quote ([arr] [arr off] [arr off end])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[arr] [arr off] [arr off end]], :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}}, :name cljs.core/array-chunk, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[arr] [arr off] [arr off end]], :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}, :method-params [[arr] [arr off] [arr off end]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag cljs.core/ArrayChunk} {:fixed-arity 2, :variadic? false, :tag cljs.core/ArrayChunk} {:fixed-arity 3, :variadic? false, :tag cljs.core/ArrayChunk}], :line 3553, :end-line 3553, :max-fixed-arity 3, :fn-var true, :arglists ([arr] [arr off] [arr off end])}, t_cljs$core9711 {:num-fields 1, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t_cljs$core9711, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 4017, :record false, :tag function, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11266, :column 7, :end-line 11266, :end-column 18, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, :name cljs.core/dispatch-fn, :file "cljs/core.cljs", :end-column 18, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11266, :ret-tag any, :end-line 11266, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, bit-shift-right-zero-fill {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2919, :column 7, :end-line 2919, :end-column 32, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, :name cljs.core/bit-shift-right-zero-fill, :file "cljs/core.cljs", :end-column 32, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2919, :ret-tag number, :end-line 2919, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, js-reserved? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11478, :column 8, :end-line 11478, :end-column 20, :private true, :arglists (quote ([x]))}, :private true, :name cljs.core/js-reserved?, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11478, :ret-tag any, :end-line 11478, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -as-transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 796, :column 9, :end-line 796, :end-column 22, :tag clj, :protocol cljs.core/IEditableCollection, :doc "Returns a new, transient version of the collection, in constant time.", :arglists (quote ([coll]))}, :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 794, :ret-tag clj, :end-line 796, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, dorun {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9953, :column 7, :end-line 9953, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [n coll]], :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/dorun, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [n coll]], :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params [[coll] [n coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag clj-nil} {:fixed-arity 2, :variadic? false, :tag clj-nil}], :line 9953, :end-line 9953, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil."}, pr-sequential-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10047, :column 7, :end-line 10047, :end-column 27, :arglists (quote ([writer print-one begin sep end opts coll]))}, :name cljs.core/pr-sequential-writer, :file "cljs/core.cljs", :end-column 27, :method-params ([writer print-one begin sep end opts coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10047, :end-line 10047, :max-fixed-arity 7, :fn-var true, :arglists (quote ([writer print-one begin sep end opts coll]))}, simple-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3388, :column 7, :end-line 3388, :end-column 21, :arglists (quote ([x])), :doc "Return true if x is a symbol without a namespace"}, :name cljs.core/simple-symbol?, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3388, :ret-tag boolean, :end-line 3388, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol without a namespace"}, accumulating-seq-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1822, :column 8, :end-line 1822, :end-column 30, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/accumulating-seq-count, :file "cljs/core.cljs", :end-column 30, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1822, :ret-tag number, :end-line 1822, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IIndexed {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 22, :column 14, :line 605, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :end-line 605, :sigs {:-nth {:name -nth, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."}}, :doc "Protocol for collections to provide indexed-based access to their items.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IIndexed, :file "cljs/core.cljs", :end-column 22, :column 1, :line 605, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :info nil, :end-line 605, :tag any, :sigs {:-nth {:name -nth, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."}}, :impls #{cljs.core/RangeChunk cljs.core/TransientVector cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayChunk cljs.core/Range cljs.core/RedNode}, :doc "Protocol for collections to provide indexed-based access to their items.", :jsdoc ("@interface")}, disj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2113, :column 7, :end-line 2113, :end-column 11, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [coll k]], :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/disj, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [coll k]], :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params [[coll] [coll k]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag #{clj clj-nil}} {:fixed-arity 2, :variadic? true, :tag #{clj clj-nil}}], :line 2113, :end-line 2113, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, MultiIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/MultiIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 4126, :record false, :end-line 4126, :tag function, :skip-protocol-flag nil}, IPrintWithWriter {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 30, :column 14, :line 770, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :end-line 770, :sigs {:-pr-writer {:name -pr-writer, :arglists ([o writer opts]), :doc nil}}, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IPrintWithWriter, :file "cljs/core.cljs", :end-column 30, :column 1, :line 770, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :info nil, :end-line 770, :tag any, :sigs {:-pr-writer {:name -pr-writer, :arglists ([o writer opts]), :doc nil}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Volatile cljs.core/Keyword cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/Delay cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ExceptionInfo cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral cljs.core/Cycle cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/TransformerIterator cljs.core/RSeq cljs.core/Iterate cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :jsdoc ("@interface")}, ->UUID {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable cljs.core/IUUID}, :file "cljs/core.cljs", :end-column 14, :column 10, :factory :positional, :line 11273, :end-line 11273, :arglists (quote ([uuid __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}, :doc "Positional factory function for cljs.core/UUID."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable cljs.core/IUUID}, :name cljs.core/->UUID, :file "cljs/core.cljs", :end-column 14, :method-params ([uuid __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 11273, :ret-tag cljs.core/UUID, :end-line 11273, :max-fixed-arity 2, :fn-var true, :arglists (quote ([uuid __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}, :doc "Positional factory function for cljs.core/UUID."}, IVector {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 21, :column 14, :line 679, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :end-line 679, :sigs {:-assoc-n {:name -assoc-n, :arglists ([coll n val]), :doc "Returns a new vector with value val added at position n."}}, :doc "Protocol for adding vector functionality to collections.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IVector, :file "cljs/core.cljs", :end-column 21, :column 1, :line 679, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :info nil, :end-line 679, :tag any, :sigs {:-assoc-n {:name -assoc-n, :arglists ([coll n val]), :doc "Returns a new vector with value val added at position n."}}, :impls #{cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for adding vector functionality to collections.", :jsdoc ("@interface")}, IIterable {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 23, :column 14, :line 878, :protocol-info {:methods {-iterator [[coll]]}}, :end-line 878, :sigs {:-iterator {:name -iterator, :arglists ([coll]), :doc "Returns an iterator for coll."}}, :doc "Protocol for iterating over a collection.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IIterable, :file "cljs/core.cljs", :end-column 23, :column 1, :line 878, :protocol-info {:methods {-iterator [[coll]]}}, :info nil, :end-line 878, :tag any, :sigs {:-iterator {:name -iterator, :arglists ([coll]), :doc "Returns an iterator for coll."}}, :impls #{cljs.core/PersistentHashMap cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayNode cljs.core/PersistentHashSet cljs.core/HashCollisionNode cljs.core/Range cljs.core/BitmapIndexedNode}, :doc "Protocol for iterating over a collection.", :jsdoc ("@interface")}, ->MultiIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 23, :column 10, :factory :positional, :line 4126, :end-line 4126, :arglists (quote ([iters])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/MultiIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->MultiIterator, :file "cljs/core.cljs", :end-column 23, :method-params ([iters]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4126, :ret-tag cljs.core/MultiIterator, :end-line 4126, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iters])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/MultiIterator."}, *2 {:name cljs.core/*2, :file "cljs/core.cljs", :line 209, :column 1, :end-line 211, :end-column 5, :doc "bound in a repl thread to the second most recent value printed", :meta {:file "cljs/core.cljs", :line 211, :column 3, :end-line 211, :end-column 5, :doc "bound in a repl thread to the second most recent value printed"}}, eval {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11740, :column 7, :end-line 11740, :end-column 11, :arglists (quote ([form])), :doc "Evaluates the form data structure (not text!) and returns the result.\n  Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\n  which sets up an implementation of cljs.core/*eval* for that environment."}, :name cljs.core/eval, :file "cljs/core.cljs", :end-column 11, :method-params ([form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11740, :ret-tag ignore, :end-line 11740, :max-fixed-arity 1, :fn-var true, :arglists (quote ([form])), :doc "Evaluates the form data structure (not text!) and returns the result.\n  Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\n  which sets up an implementation of cljs.core/*eval* for that environment."}, Eduction {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/Eduction, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 10672, :record false, :end-line 10672, :tag function, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}}, pv-clone-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5371, :column 8, :end-line 5371, :end-column 21, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/pv-clone-node, :file "cljs/core.cljs", :end-column 21, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5371, :ret-tag cljs.core/VectorNode, :end-line 5371, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3295, :column 7, :end-line 3295, :end-column 11, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and coll is the rest."}, :name cljs.core/cons, :file "cljs/core.cljs", :end-column 11, :method-params ([x coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3295, :ret-tag clj, :end-line 3295, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and coll is the rest."}, PersistentTreeSet {:num-fields 3, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentTreeSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 9322, :record false, :end-line 9322, :tag function, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, ->HashSetIter {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 21, :column 10, :factory :positional, :line 9151, :end-line 9151, :arglists (quote ([iter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/HashSetIter."}, :protocols #{cljs.core/Object}, :name cljs.core/->HashSetIter, :file "cljs/core.cljs", :end-column 21, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 9151, :ret-tag cljs.core/HashSetIter, :end-line 9151, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/HashSetIter."}, ns-lookup {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11583, :column 8, :end-line 11583, :end-column 17, :private true, :arglists (quote ([ns-obj k])), :doc "Bootstrap only."}, :private true, :name cljs.core/ns-lookup, :file "cljs/core.cljs", :end-column 17, :method-params ([ns-obj k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11583, :ret-tag function, :end-line 11583, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ns-obj k])), :doc "Bootstrap only."}, floats {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2837, :column 7, :end-line 2837, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/floats, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2837, :end-line 2837, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, TransientVector {:meta {:file "cljs/core.cljs", :line 5492, :column 44, :end-line 5492, :end-column 59, :declared true}, :num-fields 4, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientVector, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 6056, :record false, :declared true, :end-line 6056, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, pos? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2947, :column 16, :end-line 2947, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is greater than zero, else false"}, :name cljs.core/pos?, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2947, :ret-tag boolean, :end-line 2947, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is greater than zero, else false"}, fnil {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4344, :column 7, :end-line 4344, :end-column 11, :arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[f x] [f x y] [f x y z]], :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}}, :name cljs.core/fnil, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[f x] [f x y] [f x y z]], :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}, :method-params [[f x] [f x y] [f x y z]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag function} {:fixed-arity 3, :variadic? false, :tag function} {:fixed-arity 4, :variadic? false, :tag function}], :line 4344, :end-line 4344, :max-fixed-arity 4, :fn-var true, :arglists ([f x] [f x y] [f x y z]), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched."}, merge-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9117, :column 7, :end-line 9117, :end-column 17, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}}, :name cljs.core/merge-with, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :method-params [(f maps)], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? true, :tag #{nil any clj-nil}}], :line 9117, :ret-tag any, :end-line 9117, :max-fixed-arity 1, :fn-var true, :arglists ([f & maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter)."}, nthrest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1941, :column 7, :end-line 1941, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, :name cljs.core/nthrest, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1941, :end-line 1941, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, *warn-on-infer* {:name cljs.core/*warn-on-infer*, :file "cljs/core.cljs", :line 33, :column 1, :end-line 33, :end-column 21, :meta {:file "cljs/core.cljs", :line 33, :column 6, :end-line 33, :end-column 21}, :tag boolean}, -find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 649, :column 4, :end-line 649, :end-column 9, :protocol cljs.core/IFind, :doc "Returns the map entry for key, or nil if key not present.", :arglists (quote ([coll k]))}, :protocol cljs.core/IFind, :name cljs.core/-find, :file "cljs/core.cljs", :end-column 9, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 647, :ret-tag any, :end-line 649, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, sequential? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2155, :column 7, :end-line 2155, :end-column 18, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, :name cljs.core/sequential?, :file "cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2155, :ret-tag boolean, :end-line 2155, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, tree-map-replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8735, :column 8, :end-line 8735, :end-column 24, :private true, :arglists (quote ([comp tree k v]))}, :private true, :name cljs.core/tree-map-replace, :file "cljs/core.cljs", :end-column 24, :method-params ([comp tree k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8735, :ret-tag any, :end-line 8735, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k v]))}, checked-aset' {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 494, :column 8, :end-line 494, :end-column 21, :private true, :arglists (quote ([array idx val] [array idx idx2 & idxv])), :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[array idx val]], :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/checked-aset', :file "cljs/core.cljs", :end-column 21, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[array idx val]], :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params [[array idx val]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 3, :variadic? false, :tag any} {:fixed-arity 3, :variadic? true, :tag any}], :line 494, :end-line 494, :max-fixed-arity 3, :fn-var true, :arglists ([array idx val] [array idx idx2 & idxv])}, m3-mix-H1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 930, :column 15, :end-line 930, :end-column 24, :tag number, :arglists (quote ([h1 k1]))}, :name cljs.core/m3-mix-H1, :file "cljs/core.cljs", :end-column 24, :method-params ([h1 k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 930, :ret-tag number, :end-line 930, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 k1]))}, RecordIter {:num-fields 5, :protocols #{cljs.core/Object}, :name cljs.core/RecordIter, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 6532, :record false, :end-line 6532, :tag function, :skip-protocol-flag nil}, ->TransientArrayMap {:protocol-inline nil, :meta {:protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 27, :column 10, :factory :positional, :line 7052, :end-line 7052, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TransientArrayMap."}, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientArrayMap, :file "cljs/core.cljs", :end-column 27, :method-params ([editable? len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7052, :ret-tag cljs.core/TransientArrayMap, :end-line 7052, :max-fixed-arity 3, :fn-var true, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TransientArrayMap."}, re-seq* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10014, :column 8, :end-line 10014, :end-column 15, :private true, :arglists (quote ([re s]))}, :private true, :name cljs.core/re-seq*, :file "cljs/core.cljs", :end-column 15, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10014, :ret-tag #{clj clj-nil}, :end-line 10014, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s]))}, prim-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1675, :column 7, :end-line 1675, :end-column 15, :arglists (quote ([prim] [prim i])), :doc "Create seq from a primitive JavaScript Array-like.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[prim] [prim i]], :arglists ([prim] [prim i]), :arglists-meta (nil nil)}}, :name cljs.core/prim-seq, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[prim] [prim i]], :arglists ([prim] [prim i]), :arglists-meta (nil nil)}, :method-params [[prim] [prim i]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag #{cljs.core/IndexedSeq clj-nil}}], :line 1675, :end-line 1675, :max-fixed-arity 2, :fn-var true, :arglists ([prim] [prim i]), :doc "Create seq from a primitive JavaScript Array-like."}, *print-level* {:meta {:file "cljs/core.cljs", :line 169, :column 3, :end-line 169, :end-column 16, :dynamic true, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :jsdoc ["@type {null|number}"]}, :name cljs.core/*print-level*, :file "cljs/core.cljs", :end-column 16, :column 1, :dynamic true, :line 158, :end-line 169, :tag any, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :jsdoc ["@type {null|number}"]}, shuffle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2490, :column 7, :end-line 2490, :end-column 14, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, :name cljs.core/shuffle, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2490, :ret-tag #{clj cljs.core/IVector any cljs.core/MetaFn clj-nil}, :end-line 2490, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, ChunkedSeq {:meta {:file "cljs/core.cljs", :line 2183, :column 22, :end-line 2183, :end-column 32, :declared true}, :num-fields 6, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ChunkedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5746, :record false, :declared true, :end-line 5746, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, hash-keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3303, :column 7, :end-line 3303, :end-column 19, :arglists (quote ([k]))}, :name cljs.core/hash-keyword, :file "cljs/core.cljs", :end-column 19, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3303, :ret-tag number, :end-line 3303, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2363, :column 7, :end-line 2363, :end-column 11, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, :name cljs.core/find, :file "cljs/core.cljs", :end-column 11, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2363, :ret-tag #{any cljs.core/MapEntry clj-nil}, :end-line 2363, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, alength {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 517, :column 15, :end-line 517, :end-column 22, :tag number, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, :name cljs.core/alength, :file "cljs/core.cljs", :end-column 22, :method-params ([array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 517, :ret-tag number, :end-line 517, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, bit-xor {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2863, :column 7, :end-line 2863, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise exclusive or", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x y]], :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-xor, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x y]], :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params [[x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2863, :end-line 2863, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise exclusive or"}, ->IndexedSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 20, :column 10, :factory :positional, :line 1585, :end-line 1585, :arglists (quote ([arr i meta])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/IndexedSeq."}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->IndexedSeq, :file "cljs/core.cljs", :end-column 20, :method-params ([arr i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 1585, :ret-tag cljs.core/IndexedSeq, :end-line 1585, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i meta])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/IndexedSeq."}, ObjMap {:num-fields 5, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/ObjMap, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 6412, :record false, :end-line 6412, :tag function, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unsigned-bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2923, :column 7, :end-line 2923, :end-column 31, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, :name cljs.core/unsigned-bit-shift-right, :file "cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2923, :ret-tag number, :end-line 2923, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, ES6SetEntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6SetEntriesIterator, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 6558, :record false, :end-line 6558, :tag function, :skip-protocol-flag nil}, neg? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2956, :column 16, :end-line 2956, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, :name cljs.core/neg?, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2956, :ret-tag boolean, :end-line 2956, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, Cons {:num-fields 4, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cons, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 3235, :record false, :end-line 3235, :tag function, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11037, :column 4, :end-line 11037, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11034, :ret-tag any, :end-line 11037, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->StringIter {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 20, :column 10, :factory :positional, :line 4023, :end-line 4023, :arglists (quote ([s i])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/StringIter."}, :protocols #{cljs.core/Object}, :name cljs.core/->StringIter, :file "cljs/core.cljs", :end-column 20, :method-params ([s i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4023, :ret-tag cljs.core/StringIter, :end-line 4023, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s i])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/StringIter."}, js-invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 532, :column 7, :end-line 532, :end-column 16, :arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}}, :name cljs.core/js-invoke, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}, :method-params [(obj s args)], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? true, :tag any}], :line 532, :ret-tag any, :end-line 532, :max-fixed-arity 2, :fn-var true, :arglists ([obj s & args]), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name."}, ->List {:protocol-inline nil, :meta {:protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 14, :column 10, :factory :positional, :line 3052, :end-line 3052, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/List."}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->List, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 3052, :ret-tag cljs.core/List, :end-line 3052, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/List."}, m3-mix-K1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 927, :column 15, :end-line 927, :end-column 24, :tag number, :arglists (quote ([k1]))}, :name cljs.core/m3-mix-K1, :file "cljs/core.cljs", :end-column 24, :method-params ([k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 927, :ret-tag number, :end-line 927, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([k1]))}, Iterate {:num-fields 5, :protocols #{cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Iterate, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 5038, :record false, :end-line 5038, :tag function, :skip-protocol-flag #{cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, unchecked-float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2728, :column 15, :end-line 2728, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-float, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2728, :ret-tag number, :end-line 2728, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, undefined? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2241, :column 16, :end-line 2241, :end-column 26, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, :name cljs.core/undefined?, :file "cljs/core.cljs", :end-column 26, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2241, :ret-tag boolean, :end-line 2241, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, IMeta {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 19, :column 14, :line 692, :protocol-info {:methods {-meta [[o]]}}, :end-line 692, :sigs {:-meta {:name -meta, :arglists ([o]), :doc "Returns the metadata of object o."}}, :doc "Protocol for accessing the metadata of an object.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IMeta, :file "cljs/core.cljs", :end-column 19, :column 1, :line 692, :protocol-info {:methods {-meta [[o]]}}, :info nil, :end-line 692, :tag any, :sigs {:-meta {:name -meta, :arglists ([o]), :doc "Returns the metadata of object o."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/t_cljs$core11293 cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/Cycle cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/Iterate cljs.core/PersistentHashSet function cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for accessing the metadata of an object.", :jsdoc ("@interface")}, reduced? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1452, :column 7, :end-line 1452, :end-column 15, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, :name cljs.core/reduced?, :file "cljs/core.cljs", :end-column 15, :method-params ([r]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1452, :ret-tag boolean, :end-line 1452, :max-fixed-arity 1, :fn-var true, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, apply-to {:protocol-inline nil, :meta {:arglists (quote ([f argc args])), :file "cljs/core.cljs"}, :name cljs.core/apply-to, :file "cljs/core.cljs", :method-params ([f argc args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3894, :ret-tag any, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f argc args]))}, disj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3879, :column 7, :end-line 3879, :end-column 12, :arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tcoll val]], :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}}, :name cljs.core/disj!, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tcoll val]], :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}, :method-params [[tcoll val]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag clj} {:fixed-arity 2, :variadic? true, :tag clj}], :line 3879, :end-line 3879, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll val] [tcoll val & vals]), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, -lookup {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 634, :column 4, :end-line 634, :end-column 11, :protocol cljs.core/ILookup, :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists (quote ([o k] [o k not-found])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[o k] [o k not-found]], :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/ILookup, :name cljs.core/-lookup, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[o k] [o k not-found]], :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params [[o k] [o k not-found]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag any}], :line 632, :end-line 634, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."}, float? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2336, :column 7, :end-line 2336, :end-column 13, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, :name cljs.core/float?, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2336, :ret-tag boolean, :end-line 2336, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, ICloneable {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 24, :column 14, :line 578, :protocol-info {:methods {-clone [[value]]}}, :end-line 578, :sigs {:-clone {:name -clone, :arglists ([value]), :doc "Creates a clone of value."}}, :doc "Protocol for cloning a value.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ICloneable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 578, :protocol-info {:methods {-clone [[value]]}}, :info nil, :end-line 578, :tag any, :sigs {:-clone {:name -clone, :arglists ([value]), :doc "Creates a clone of value."}}, :impls #{cljs.core/PersistentHashMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Range}, :doc "Protocol for cloning a value.", :jsdoc ("@interface")}, IEncodeClojure {:meta {:file "cljs/core.cljs", :line 10764, :column 14, :end-line 10764, :end-column 28, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-js->clj [[x options]]}}, :sigs {:-js->clj {:name -js->clj, :arglists ([x options]), :doc "Transforms JavaScript values to Clojure"}}}, :protocol-symbol true, :name cljs.core/IEncodeClojure, :file "cljs/core.cljs", :end-column 28, :column 1, :line 10764, :protocol-info {:methods {-js->clj [[x options]]}}, :info nil, :end-line 10764, :tag any, :sigs {:-js->clj {:name -js->clj, :arglists ([x options]), :doc "Transforms JavaScript values to Clojure"}}, :impls #{}, :jsdoc ("@interface")}, booleans {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2832, :column 7, :end-line 2832, :end-column 15, :arglists (quote ([x]))}, :name cljs.core/booleans, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2832, :end-line 2832, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ArrayList {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 19, :column 10, :factory :positional, :line 9556, :end-line 9556, :arglists (quote ([arr])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ArrayList."}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayList, :file "cljs/core.cljs", :end-column 19, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 9556, :ret-tag cljs.core/ArrayList, :end-line 9556, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ArrayList."}, RSeq {:meta {:file "cljs/core.cljs", :line 1532, :column 40, :end-line 1532, :end-column 44, :declared true}, :num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/RSeq, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 1692, :record false, :declared true, :end-line 1692, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, mask {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7153, :column 8, :end-line 7153, :end-column 12, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/mask, :file "cljs/core.cljs", :end-column 12, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 7153, :ret-tag number, :end-line 7153, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, int-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3679, :column 7, :end-line 3679, :end-column 16, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size-or-seq] [size init-val-or-seq]], :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/int-array, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size-or-seq] [size init-val-or-seq]], :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params [[size-or-seq] [size init-val-or-seq]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag #{any array}} {:fixed-arity 2, :variadic? false, :tag array}], :line 3679, :end-line 3679, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure."}, find-and-cache-best-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11006, :column 8, :end-line 11006, :end-column 34, :private true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]))}, :private true, :name cljs.core/find-and-cache-best-method, :file "cljs/core.cljs", :end-column 34, :method-params ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11006, :ret-tag #{any clj-nil}, :end-line 11006, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]))}, set? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2140, :column 7, :end-line 2140, :end-column 11, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, :name cljs.core/set?, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2140, :ret-tag boolean, :end-line 2140, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, iterable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1203, :column 7, :end-line 1203, :end-column 16, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, :name cljs.core/iterable?, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1203, :ret-tag boolean, :end-line 1203, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, cat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10609, :column 7, :end-line 10609, :end-column 10, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :added "1.7"}, :added "1.7", :name cljs.core/cat, :file "cljs/core.cljs", :end-column 10, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10609, :ret-tag function, :end-line 10609, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction."}, ->ES6EntriesIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 28, :column 10, :factory :positional, :line 6545, :end-line 6545, :arglists (quote ([s])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ES6EntriesIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6EntriesIterator, :file "cljs/core.cljs", :end-column 28, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6545, :ret-tag cljs.core/ES6EntriesIterator, :end-line 6545, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ES6EntriesIterator."}, divide {:name cljs.core/divide, :file "cljs/core.cljs", :line 2636, :column 1, :end-line 2636, :end-column 16, :declared true, :meta {:file "cljs/core.cljs", :line 2636, :column 10, :end-line 2636, :end-column 16, :declared true}}, js-reserved-arr {:meta {:file "cljs/core.cljs", :line 11459, :column 3, :end-line 11459, :end-column 18, :private true, :jsdoc ["@type {*}"]}, :private true, :name cljs.core/js-reserved-arr, :file "cljs/core.cljs", :end-column 18, :column 1, :line 11456, :end-line 11459, :tag array, :jsdoc ["@type {*}"]}, -pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 776, :column 4, :end-line 776, :end-column 14, :protocol cljs.core/IPrintWithWriter, :doc nil, :arglists (quote ([o writer opts]))}, :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :file "cljs/core.cljs", :end-column 14, :method-params ([o writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 770, :ret-tag any, :end-line 776, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o writer opts])), :doc nil}, flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10080, :column 7, :end-line 10080, :end-column 12, :arglists (quote ([]))}, :name cljs.core/flush, :file "cljs/core.cljs", :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10080, :ret-tag clj-nil, :end-line 10080, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, set-from-indexed-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9423, :column 7, :end-line 9423, :end-column 27, :arglists (quote ([iseq]))}, :name cljs.core/set-from-indexed-seq, :file "cljs/core.cljs", :end-column 27, :method-params ([iseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9423, :ret-tag clj, :end-line 9423, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iseq]))}, maybe-init-tapset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11550, :column 8, :end-line 11550, :end-column 25, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/maybe-init-tapset, :file "cljs/core.cljs", :end-column 25, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11550, :ret-tag #{nil clj-nil}, :end-line 11550, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, take-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9598, :column 7, :end-line 9598, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred coll]], :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-while, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred coll]], :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params [[pred] [pred coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 9598, :end-line 9598, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, vary-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3989, :column 7, :end-line 3989, :end-column 16, :arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :top-fn {:variadic? true, :fixed-arity 6, :max-fixed-arity 6, :method-params [[obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]], :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}}, :name cljs.core/vary-meta, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? true, :fixed-arity 6, :max-fixed-arity 6, :method-params [[obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]], :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}, :method-params [[obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]], :protocol-impl nil, :fixed-arity 6, :arglists-meta (nil nil nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag #{clj cljs.core/MetaFn clj-nil}} {:fixed-arity 3, :variadic? false, :tag #{clj cljs.core/MetaFn clj-nil}} {:fixed-arity 4, :variadic? false, :tag #{clj cljs.core/MetaFn clj-nil}} {:fixed-arity 5, :variadic? false, :tag #{clj cljs.core/MetaFn clj-nil}} {:fixed-arity 6, :variadic? false, :tag #{clj cljs.core/MetaFn clj-nil}} {:fixed-arity 6, :variadic? true, :tag #{clj cljs.core/MetaFn clj-nil}}], :line 3989, :end-line 3989, :max-fixed-arity 6, :fn-var true, :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata."}, INext {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 19, :column 14, :line 624, :protocol-info {:methods {-next [[coll]]}}, :end-line 624, :sigs {:-next {:name -next, :arglists ([coll]), :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil"}}, :doc "Protocol for accessing the next items of a collection.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/INext, :file "cljs/core.cljs", :end-column 19, :column 1, :line 624, :protocol-info {:methods {-next [[coll]]}}, :info nil, :end-line 624, :tag any, :sigs {:-next {:name -next, :arglists ([coll]), :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil"}}, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/Cycle cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/Iterate cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq}, :doc "Protocol for accessing the next items of a collection.", :jsdoc ("@interface")}, is_proto_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 296, :column 7, :end-line 296, :end-column 16, :arglists (quote ([x]))}, :name cljs.core/is_proto_, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 296, :ret-tag boolean, :end-line 296, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, START {:name cljs.core/START, :file "cljs/core.cljs", :line 4048, :column 1, :end-line 4048, :end-column 11, :meta {:file "cljs/core.cljs", :line 4048, :column 6, :end-line 4048, :end-column 11}, :tag object}, ICounted {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 22, :column 14, :line 583, :protocol-info {:methods {-count [[coll]]}}, :end-line 583, :sigs {:-count {:name -count, :arglists ([coll]), :doc "Calculates the count of coll in constant time. Used by cljs.core/count."}}, :doc "Protocol for adding the ability to count a collection in constant time.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ICounted, :file "cljs/core.cljs", :end-column 22, :column 1, :line 583, :protocol-info {:methods {-count [[coll]]}}, :info nil, :end-line 583, :tag any, :sigs {:-count {:name -count, :arglists ([coll]), :doc "Calculates the count of coll in constant time. Used by cljs.core/count."}}, :impls #{nil cljs.core/RangeChunk cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/Subvec cljs.core/TransientHashMap cljs.core/ChunkBuffer cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransientArrayMap cljs.core/RSeq cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/ArrayChunk cljs.core/PersistentTreeSet cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to count a collection in constant time.", :jsdoc ("@interface")}, IMapEntry {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 23, :column 14, :line 657, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :end-line 657, :sigs {:-key {:name -key, :arglists ([coll]), :doc "Returns the key of the map entry."}, :-val {:name -val, :arglists ([coll]), :doc "Returns the value of the map entry."}}, :doc "Protocol for examining a map entry.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IMapEntry, :file "cljs/core.cljs", :end-column 23, :column 1, :line 657, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :info nil, :end-line 657, :tag any, :sigs {:-key {:name -key, :arglists ([coll]), :doc "Returns the key of the map entry."}, :-val {:name -val, :arglists ([coll]), :doc "Returns the value of the map entry."}}, :impls #{cljs.core/BlackNode cljs.core/MapEntry cljs.core/RedNode}, :doc "Protocol for examining a map entry.", :jsdoc ("@interface")}, pv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5476, :column 8, :end-line 5476, :end-column 17, :private true, :arglists (quote ([pv f start end] [pv f init start end])), :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[pv f start end] [pv f init start end]], :arglists ([pv f start end] [pv f init start end]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/pv-reduce, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[pv f start end] [pv f init start end]], :arglists ([pv f start end] [pv f init start end]), :arglists-meta (nil nil)}, :method-params [[pv f start end] [pv f init start end]], :protocol-impl nil, :fixed-arity 5, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 4, :variadic? false, :tag any} {:fixed-arity 5, :variadic? false, :tag #{nil any}}], :line 5476, :end-line 5476, :max-fixed-arity 5, :fn-var true, :arglists ([pv f start end] [pv f init start end])}, <= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2657, :column 16, :end-line 2657, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<=, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? true, :tag boolean}], :line 2657, :ret-tag boolean, :end-line 2657, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false."}, MODULE_INFOS {:name cljs.core/MODULE_INFOS, :file "cljs/core.cljs", :line 40, :column 1, :end-line 40, :end-column 18, :meta {:file "cljs/core.cljs", :line 40, :column 6, :end-line 40, :end-column 18}, :tag clj-nil}, conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3838, :column 7, :end-line 3838, :end-column 12, :arglists (quote ([] [tcoll] [tcoll val] [tcoll val & vals])), :doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [tcoll] [tcoll val]], :arglists ([] [tcoll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj!, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [tcoll] [tcoll val]], :arglists ([] [tcoll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}, :method-params [[] [tcoll] [tcoll val]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag clj} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag clj} {:fixed-arity 2, :variadic? true, :tag clj}], :line 3838, :end-line 3838, :max-fixed-arity 2, :fn-var true, :arglists ([] [tcoll] [tcoll val] [tcoll val & vals]), :doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type."}, -pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 675, :column 9, :end-line 675, :end-column 13, :tag clj, :protocol cljs.core/IStack, :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-pop, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 669, :ret-tag clj, :end-line 675, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."}, array-index-of-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6600, :column 8, :end-line 6600, :end-column 33, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-identical?, :file "cljs/core.cljs", :end-column 33, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6600, :ret-tag number, :end-line 6600, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, repeatedly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5029, :column 7, :end-line 5029, :end-column 17, :arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [n f]], :arglists ([f] [n f]), :arglists-meta (nil nil)}}, :name cljs.core/repeatedly, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [n f]], :arglists ([f] [n f]), :arglists-meta (nil nil)}, :method-params [[f] [n f]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 5029, :end-line 5029, :max-fixed-arity 2, :fn-var true, :arglists ([f] [n f]), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it"}, zipmap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9526, :column 7, :end-line 9526, :end-column 13, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, :name cljs.core/zipmap, :file "cljs/core.cljs", :end-column 13, :method-params ([keys vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9526, :ret-tag clj, :end-line 9526, :max-fixed-arity 2, :fn-var true, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, reset-vals! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4495, :column 7, :end-line 4495, :end-column 18, :arglists (quote ([a new-value])), :doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :added "1.9"}, :added "1.9", :name cljs.core/reset-vals!, :file "cljs/core.cljs", :end-column 18, :method-params ([a new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4495, :ret-tag cljs.core/IVector, :end-line 4495, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a new-value])), :doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset."}, IStack {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 20, :column 14, :line 669, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :end-line 669, :sigs {:-peek {:name -peek, :arglists ([coll]), :doc "Returns the item from the top of the stack. Is used by cljs.core/peek."}, :-pop {:name -pop, :arglists ([coll]), :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."}}, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IStack, :file "cljs/core.cljs", :end-column 20, :column 1, :line 669, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :info nil, :end-line 669, :tag any, :sigs {:-peek {:name -peek, :arglists ([coll]), :doc "Returns the item from the top of the stack. Is used by cljs.core/peek."}, :-pop {:name -pop, :arglists ([coll]), :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."}}, :impls #{cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RedNode}, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :jsdoc ("@interface")}, -remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 791, :column 4, :end-line 791, :end-column 17, :protocol cljs.core/IWatchable, :doc "Removes watcher that corresponds to key from this.", :arglists (quote ([this key]))}, :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :file "cljs/core.cljs", :end-column 17, :method-params ([this key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 784, :ret-tag any, :end-line 791, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this key])), :doc "Removes watcher that corresponds to key from this."}, IVolatile {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 23, :column 14, :line 872, :protocol-info {:methods {-vreset! [[o new-value]]}}, :end-line 872, :sigs {:-vreset! {:name -vreset!, :arglists ([o new-value]), :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."}}, :doc "Protocol for adding volatile functionality.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IVolatile, :file "cljs/core.cljs", :end-column 23, :column 1, :line 872, :protocol-info {:methods {-vreset! [[o new-value]]}}, :info nil, :end-line 872, :tag any, :sigs {:-vreset! {:name -vreset!, :arglists ([o new-value]), :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."}}, :impls #{cljs.core/Volatile}, :doc "Protocol for adding volatile functionality.", :jsdoc ("@interface")}, remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5193, :column 7, :end-line 5193, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred coll]], :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/remove, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred coll]], :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params [[pred] [pred coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 5193, :end-line 5193, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->BitmapIndexedNode {:protocol-inline nil, :meta {:protocols #{cljs.core/Object cljs.core/IIterable}, :file "cljs/core.cljs", :end-column 27, :column 10, :factory :positional, :line 7244, :end-line 7244, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag #{cljs.core/IIterable}, :doc "Positional factory function for cljs.core/BitmapIndexedNode."}, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/->BitmapIndexedNode, :file "cljs/core.cljs", :end-column 27, :method-params ([edit bitmap arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7244, :ret-tag cljs.core/BitmapIndexedNode, :end-line 7244, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag #{cljs.core/IIterable}, :doc "Positional factory function for cljs.core/BitmapIndexedNode."}, * {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2629, :column 15, :end-line 2629, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/*, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params [[] [x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag number} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2629, :ret-tag number, :end-line 2629, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, re-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10034, :column 7, :end-line 10034, :end-column 17, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, :name cljs.core/re-pattern, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10034, :ret-tag #{nil js/RegExp}, :end-line 10034, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, min {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2704, :column 15, :end-line 2704, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2704, :ret-tag number, :end-line 2704, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the least of the nums."}, array-index-of-nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6572, :column 8, :end-line 6572, :end-column 27, :private true, :arglists (quote ([arr]))}, :private true, :name cljs.core/array-index-of-nil?, :file "cljs/core.cljs", :end-column 27, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6572, :ret-tag number, :end-line 6572, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr]))}, -persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 803, :column 9, :end-line 803, :end-column 21, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Creates a persistent data structure from tcoll and returns it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :file "cljs/core.cljs", :end-column 21, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 799, :ret-tag clj, :end-line 803, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Creates a persistent data structure from tcoll and returns it."}, -nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 607, :column 4, :end-line 607, :end-column 8, :protocol cljs.core/IIndexed, :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll n] [coll n not-found]], :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/IIndexed, :name cljs.core/-nth, :file "cljs/core.cljs", :end-column 8, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll n] [coll n not-found]], :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params [[coll n] [coll n not-found]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag any}], :line 605, :end-line 607, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."}, pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3873, :column 7, :end-line 3873, :end-column 11, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll"}, :name cljs.core/pop!, :file "cljs/core.cljs", :end-column 11, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3873, :ret-tag clj, :end-line 3873, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll"}, chunk-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3639, :column 7, :end-line 3639, :end-column 19, :arglists (quote ([b x]))}, :name cljs.core/chunk-append, :file "cljs/core.cljs", :end-column 19, :method-params ([b x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3639, :ret-tag any, :end-line 3639, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b x]))}, *unchecked-arrays* {:name cljs.core/*unchecked-arrays*, :file "cljs/core.cljs", :line 30, :column 1, :end-line 30, :end-column 24, :meta {:file "cljs/core.cljs", :line 30, :column 6, :end-line 30, :end-column 24}, :tag boolean}, prn-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10257, :column 7, :end-line 10257, :end-column 14, :arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn-str, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag string}], :line 10257, :ret-tag any, :end-line 10257, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr-str followed by (newline)"}, IReversible {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 25, :column 14, :line 741, :protocol-info {:methods {-rseq [[coll]]}}, :end-line 741, :sigs {:-rseq {:name -rseq, :arglists ([coll]), :doc "Returns a seq of the items in coll in reversed order."}}, :doc "Protocol for reversing a seq.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IReversible, :file "cljs/core.cljs", :end-column 25, :column 1, :line 741, :protocol-info {:methods {-rseq [[coll]]}}, :info nil, :end-line 741, :tag any, :sigs {:-rseq {:name -rseq, :arglists ([coll]), :doc "Returns a seq of the items in coll in reversed order."}}, :impls #{cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}, :doc "Protocol for reversing a seq.", :jsdoc ("@interface")}, reversible? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3200, :column 7, :end-line 3200, :end-column 18, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, :name cljs.core/reversible?, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3200, :ret-tag boolean, :end-line 3200, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, -realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 781, :column 13, :end-line 781, :end-column 23, :tag boolean, :protocol cljs.core/IPending, :doc "Returns true if a value for x has been produced, false otherwise.", :arglists (quote ([x]))}, :protocol cljs.core/IPending, :name cljs.core/-realized?, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 778, :ret-tag boolean, :end-line 781, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if a value for x has been produced, false otherwise."}, -add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 788, :column 4, :end-line 788, :end-column 14, :protocol cljs.core/IWatchable, :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists (quote ([this key f]))}, :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :file "cljs/core.cljs", :end-column 14, :method-params ([this key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 784, :ret-tag any, :end-line 788, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this key f])), :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch."}, -deref-with-timeout {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 690, :column 4, :end-line 690, :end-column 23, :protocol cljs.core/IDerefWithTimeout, :doc nil, :arglists (quote ([o msec timeout-val]))}, :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :file "cljs/core.cljs", :end-column 23, :method-params ([o msec timeout-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 689, :ret-tag any, :end-line 690, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o msec timeout-val])), :doc nil}, conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1794, :column 7, :end-line 1794, :end-column 11, :arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [coll] [coll x]], :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [coll] [coll x]], :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}, :method-params [[] [coll] [coll x]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag cljs.core/IVector} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag clj} {:fixed-arity 2, :variadic? true, :tag clj}], :line 1794, :end-line 1794, :max-fixed-arity 2, :fn-var true, :arglists ([] [coll] [coll x] [coll x & xs]), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type."}, -sorted-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 749, :column 9, :end-line 749, :end-column 20, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists (quote ([coll ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :file "cljs/core.cljs", :end-column 20, :method-params ([coll ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 746, :ret-tag clj, :end-line 749, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order."}, flatten1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5140, :column 8, :end-line 5140, :end-column 16, :private true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, :private true, :name cljs.core/flatten1, :file "cljs/core.cljs", :end-column 16, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5140, :ret-tag cljs.core/LazySeq, :end-line 5140, :max-fixed-arity 1, :fn-var true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, transduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2596, :column 7, :end-line 2596, :end-column 16, :arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[xform f coll] [xform f init coll]], :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/transduce, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[xform f coll] [xform f init coll]], :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}, :method-params [[xform f coll] [xform f init coll]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 3, :variadic? false, :tag any} {:fixed-arity 4, :variadic? false, :tag any}], :line 2596, :end-line 2596, :max-fixed-arity 4, :fn-var true, :arglists ([xform f coll] [xform f init coll]), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items."}, -swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 869, :column 4, :end-line 869, :end-column 10, :protocol cljs.core/ISwap, :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists (quote ([o f] [o f a] [o f a b] [o f a b xs])), :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[o f] [o f a] [o f a b] [o f a b xs]], :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}}, :protocol cljs.core/ISwap, :name cljs.core/-swap!, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[o f] [o f a] [o f a b] [o f a b xs]], :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}, :method-params [[o f] [o f a] [o f a b] [o f a b xs]], :protocol-impl nil, :fixed-arity 5, :arglists-meta (nil nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag any} {:fixed-arity 4, :variadic? false, :tag any} {:fixed-arity 5, :variadic? false, :tag any}], :line 867, :end-line 869, :max-fixed-arity 5, :fn-var true, :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :doc "Swaps the value of o to be (apply f current-value-of-atom args)."}, *print-length* {:meta {:file "cljs/core.cljs", :line 156, :column 3, :end-line 156, :end-column 17, :dynamic true, :doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :jsdoc ["@type {null|number}"]}, :name cljs.core/*print-length*, :file "cljs/core.cljs", :end-column 17, :column 1, :dynamic true, :line 146, :end-line 156, :tag any, :doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :jsdoc ["@type {null|number}"]}, js-delete {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2203, :column 7, :end-line 2203, :end-column 16, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object.\n  Returns true upon success, false otherwise."}, :name cljs.core/js-delete, :file "cljs/core.cljs", :end-column 16, :method-params ([obj key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2203, :ret-tag any, :end-line 2203, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object.\n  Returns true upon success, false otherwise."}, truth_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 221, :column 7, :end-line 221, :end-column 13, :arglists (quote ([x])), :doc "Internal - do not use!"}, :name cljs.core/truth_, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 221, :ret-tag any, :end-line 221, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Internal - do not use!"}, array-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6616, :column 7, :end-line 6616, :end-column 21, :arglists (quote ([arr k]))}, :name cljs.core/array-index-of, :file "cljs/core.cljs", :end-column 21, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6616, :ret-tag number, :end-line 6616, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->MultiFn {:protocol-inline nil, :meta {:protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :file "cljs/core.cljs", :end-column 17, :column 10, :factory :positional, :line 11048, :end-line 11048, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :doc "Positional factory function for cljs.core/MultiFn."}, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/->MultiFn, :file "cljs/core.cljs", :end-column 17, :method-params ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 11048, :ret-tag cljs.core/MultiFn, :end-line 11048, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :doc "Positional factory function for cljs.core/MultiFn."}, key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10725, :column 7, :end-line 10725, :end-column 14, :arglists (quote ([k] [k primitive-fn])), :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[k] [k primitive-fn]], :arglists ([k] [k primitive-fn]), :arglists-meta (nil nil)}}, :name cljs.core/key->js, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[k] [k primitive-fn]], :arglists ([k] [k primitive-fn]), :arglists-meta (nil nil)}, :method-params [[k] [k primitive-fn]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag #{any string}}], :line 10725, :end-line 10725, :max-fixed-arity 2, :fn-var true, :arglists ([k] [k primitive-fn])}, IEncodeJS {:meta {:file "cljs/core.cljs", :line 10718, :column 14, :end-line 10718, :end-column 23, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :sigs {:-clj->js {:name -clj->js, :arglists ([x]), :doc "Recursively transforms clj values to JavaScript"}, :-key->js {:name -key->js, :arglists ([x]), :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}}}, :protocol-symbol true, :name cljs.core/IEncodeJS, :file "cljs/core.cljs", :end-column 23, :column 1, :line 10718, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :info nil, :end-line 10718, :tag any, :sigs {:-clj->js {:name -clj->js, :arglists ([x]), :doc "Recursively transforms clj values to JavaScript"}, :-key->js {:name -key->js, :arglists ([x]), :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}}, :impls #{}, :jsdoc ("@interface")}, new-path {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5380, :column 8, :end-line 5380, :end-column 16, :private true, :arglists (quote ([edit level node]))}, :private true, :name cljs.core/new-path, :file "cljs/core.cljs", :end-column 16, :method-params ([edit level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5380, :end-line 5380, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit level node]))}, compare-and-set! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4547, :column 7, :end-line 4547, :end-column 23, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, :name cljs.core/compare-and-set!, :file "cljs/core.cljs", :end-column 23, :method-params ([a oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4547, :ret-tag boolean, :end-line 4547, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, array-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1683, :column 7, :end-line 1683, :end-column 16, :arglists (quote ([array] [array i])), :doc "Create a seq from a JavaScript array.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[array] [array i]], :arglists ([array] [array i]), :arglists-meta (nil nil)}}, :name cljs.core/array-seq, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[array] [array i]], :arglists ([array] [array i]), :arglists-meta (nil nil)}, :method-params [[array] [array i]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag #{cljs.core/IndexedSeq clj-nil}} {:fixed-arity 2, :variadic? false, :tag #{cljs.core/IndexedSeq clj-nil}}], :line 1683, :end-line 1683, :max-fixed-arity 2, :fn-var true, :arglists ([array] [array i]), :doc "Create a seq from a JavaScript array."}, array-copy-downward {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2217, :column 8, :end-line 2217, :end-column 27, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy-downward, :file "cljs/core.cljs", :end-column 27, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2217, :end-line 2217, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, pack-array-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7446, :column 8, :end-line 7446, :end-column 23, :private true, :arglists (quote ([array-node edit idx]))}, :private true, :name cljs.core/pack-array-node, :file "cljs/core.cljs", :end-column 23, :method-params ([array-node edit idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 7446, :ret-tag cljs.core/BitmapIndexedNode, :end-line 7446, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array-node edit idx]))}, interleave {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5102, :column 7, :end-line 5102, :end-column 17, :arglists (quote ([] [c1] [c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [c1] [c1 c2]], :arglists ([] [c1] [c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/interleave, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [c1] [c1 c2]], :arglists ([] [c1] [c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil nil nil)}, :method-params [[] [c1] [c1 c2]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag cljs.core/IList} {:fixed-arity 1, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 2, :variadic? true, :tag cljs.core/LazySeq}], :line 5102, :end-line 5102, :max-fixed-arity 2, :fn-var true, :arglists ([] [c1] [c1 c2] [c1 c2 & colls]), :doc "Returns a lazy seq of the first item in each coll, then the second etc."}, print-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10333, :column 7, :end-line 10333, :end-column 16, :arglists (quote ([m print-one writer opts]))}, :name cljs.core/print-map, :file "cljs/core.cljs", :end-column 16, :method-params ([m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10333, :ret-tag any, :end-line 10333, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m print-one writer opts]))}, map? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2167, :column 7, :end-line 2167, :end-column 11, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, :name cljs.core/map?, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2167, :ret-tag boolean, :end-line 2167, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, m3-C1 {:name cljs.core/m3-C1, :file "cljs/core.cljs", :line 924, :column 1, :end-line 924, :end-column 11, :meta {:file "cljs/core.cljs", :line 924, :column 6, :end-line 924, :end-column 11}, :tag number}, get {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1949, :column 7, :end-line 1949, :end-column 10, :arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[o k] [o k not-found]], :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :name cljs.core/get, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[o k] [o k not-found]], :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params [[o k] [o k not-found]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag #{any clj-nil}} {:fixed-arity 3, :variadic? false, :tag #{nil any}}], :line 1949, :end-line 1949, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Returns the value mapped to key, not-found or nil if key not present."}, identity {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2581, :column 7, :end-line 2581, :end-column 15, :arglists (quote ([x])), :doc "Returns its argument."}, :name cljs.core/identity, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2581, :end-line 2581, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns its argument."}, into {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5224, :column 7, :end-line 5224, :end-column 11, :arglists (quote ([] [to] [to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[] [to] [to from] [to xform from]], :arglists ([] [to] [to from] [to xform from]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/into, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[] [to] [to from] [to xform from]], :arglists ([] [to] [to from] [to xform from]), :arglists-meta (nil nil nil nil)}, :method-params [[] [to] [to from] [to xform from]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 0, :variadic? false, :tag cljs.core/IVector} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag #{nil clj any}} {:fixed-arity 3, :variadic? false, :tag #{clj any}}], :line 5224, :end-line 5224, :max-fixed-arity 3, :fn-var true, :arglists ([] [to] [to from] [to xform from]), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied."}, long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2822, :column 7, :end-line 2822, :end-column 11, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/long, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2822, :ret-tag number, :end-line 2822, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2723, :column 15, :end-line 2723, :end-column 21, :tag number, :arglists (quote ([x]))}, :name cljs.core/double, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2723, :ret-tag number, :end-line 2723, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, volatile? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4587, :column 7, :end-line 4587, :end-column 16, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, :name cljs.core/volatile?, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4587, :ret-tag boolean, :end-line 4587, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, ChunkBuffer {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/ChunkBuffer, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3512, :record false, :end-line 3512, :tag function, :skip-protocol-flag #{cljs.core/ICounted}}, HashSetIter {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/HashSetIter, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 9151, :record false, :end-line 9151, :tag function, :skip-protocol-flag nil}, -key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 659, :column 4, :end-line 659, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the key of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-key, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 657, :ret-tag any, :end-line 659, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the key of the map entry."}, nfirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1767, :column 7, :end-line 1767, :end-column 13, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, :name cljs.core/nfirst, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1767, :ret-tag seq, :end-line 1767, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, StringBufferWriter {:num-fields 1, :protocols #{cljs.core/IWriter}, :name cljs.core/StringBufferWriter, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 885, :record false, :end-line 885, :tag function, :skip-protocol-flag #{cljs.core/IWriter}}, meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2091, :column 7, :end-line 2091, :end-column 11, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, :name cljs.core/meta, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2091, :ret-tag #{clj-or-nil clj-nil}, :end-line 2091, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, tv-editable-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6009, :column 8, :end-line 6009, :end-column 24, :private true, :arglists (quote ([tl]))}, :private true, :name cljs.core/tv-editable-tail, :file "cljs/core.cljs", :end-column 24, :method-params ([tl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6009, :ret-tag array, :end-line 6009, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tl]))}, -kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 713, :column 4, :end-line 713, :end-column 14, :protocol cljs.core/IKVReduce, :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists (quote ([coll f init]))}, :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :file "cljs/core.cljs", :end-column 14, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 710, :ret-tag any, :end-line 713, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init])), :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."}, IHash {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 19, :column 14, :line 722, :protocol-info {:methods {-hash [[o]]}}, :end-line 722, :sigs {:-hash {:name -hash, :arglists ([o]), :doc "Returns the hash code of o."}}, :doc "Protocol for adding hashing functionality to a type.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IHash, :file "cljs/core.cljs", :end-column 19, :column 1, :line 722, :protocol-info {:methods {-hash [[o]]}}, :info nil, :end-line 722, :tag any, :sigs {:-hash {:name -hash, :arglists ([o]), :doc "Returns the hash code of o."}}, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding hashing functionality to a type.", :jsdoc ("@interface")}, bit-and-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2881, :column 7, :end-line 2881, :end-column 18, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and with complement", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x y]], :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and-not, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x y]], :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params [[x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2881, :end-line 2881, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and with complement"}, var? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1107, :column 7, :end-line 1107, :end-column 11, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, :name cljs.core/var?, :file "cljs/core.cljs", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1107, :ret-tag boolean, :end-line 1107, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, -comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 760, :column 4, :end-line 760, :end-column 15, :protocol cljs.core/ISorted, :doc "Returns the comparator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/ISorted, :name cljs.core/-comparator, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 746, :ret-tag any, :end-line 760, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the comparator for coll."}, unchecked-add-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2738, :column 15, :end-line 2738, :end-column 32, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add-int, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params [[] [x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag number} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2738, :ret-tag number, :end-line 2738, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, hash-ordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1351, :column 15, :end-line 1351, :end-column 32, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-ordered-coll, :file "cljs/core.cljs", :end-column 32, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1351, :ret-tag number, :end-line 1351, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, extend-object! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3040, :column 8, :end-line 3040, :end-column 22, :private true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, :private true, :name cljs.core/extend-object!, :file "cljs/core.cljs", :end-column 22, :method-params ([obj fn-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3040, :end-line 3040, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, do-assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5433, :column 8, :end-line 5433, :end-column 16, :private true, :arglists (quote ([pv level node i val]))}, :private true, :name cljs.core/do-assoc, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node i val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5433, :ret-tag cljs.core/VectorNode, :end-line 5433, :max-fixed-arity 5, :fn-var true, :arglists (quote ([pv level node i val]))}, reset-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10516, :column 7, :end-line 10516, :end-column 18, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, :name cljs.core/reset-meta!, :file "cljs/core.cljs", :end-column 18, :method-params ([iref m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10516, :end-line 10516, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, ->KeySeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 16, :column 10, :factory :positional, :line 8951, :end-line 8951, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/KeySeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->KeySeq, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 8951, :ret-tag cljs.core/KeySeq, :end-line 8951, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/KeySeq."}, IEquiv {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 20, :column 14, :line 717, :protocol-info {:methods {-equiv [[o other]]}}, :end-line 717, :sigs {:-equiv {:name -equiv, :arglists ([o other]), :doc "Returns true if o and other are equal, false otherwise."}}, :doc "Protocol for adding value comparison functionality to a type.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IEquiv, :file "cljs/core.cljs", :end-column 20, :column 1, :line 717, :protocol-info {:methods {-equiv [[o other]]}}, :info nil, :end-line 717, :tag any, :sigs {:-equiv {:name -equiv, :arglists ([o other]), :doc "Returns true if o and other are equal, false otherwise."}}, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq js/Date cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral number default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/NeverEquiv cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding value comparison functionality to a type.", :jsdoc ("@interface")}, tree-map-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8335, :column 8, :end-line 8335, :end-column 26, :private true, :arglists (quote ([node f init]))}, :private true, :name cljs.core/tree-map-kv-reduce, :file "cljs/core.cljs", :end-column 26, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8335, :ret-tag #{cljs.core/Reduced any}, :end-line 8335, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init]))}, cycle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4909, :column 7, :end-line 4909, :end-column 12, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, :name cljs.core/cycle, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4909, :ret-tag #{any cljs.core/Cycle}, :end-line 4909, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, -deref {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 686, :column 4, :end-line 686, :end-column 10, :protocol cljs.core/IDeref, :doc "Returns the value of the reference o.", :arglists (quote ([o]))}, :protocol cljs.core/IDeref, :name cljs.core/-deref, :file "cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 684, :ret-tag any, :end-line 686, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the value of the reference o."}, pr-writer-ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11321, :column 8, :end-line 11321, :end-column 25, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-ex-info, :file "cljs/core.cljs", :end-column 25, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11321, :ret-tag any, :end-line 11321, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, empty? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2127, :column 7, :end-line 2127, :end-column 13, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, :name cljs.core/empty?, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2127, :ret-tag boolean, :end-line 2127, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, TaggedLiteral {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/TaggedLiteral, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 11414, :record false, :end-line 11414, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}}, short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2721, :column 15, :end-line 2721, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/short, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2721, :ret-tag number, :end-line 2721, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, -clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10719, :column 4, :end-line 10719, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Recursively transforms clj values to JavaScript", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-clj->js, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10718, :ret-tag any, :end-line 10719, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms clj values to JavaScript"}, -chunked-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 842, :column 4, :end-line 842, :end-column 18, :protocol cljs.core/IChunkedSeq, :doc "Returns the first chunk in coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 840, :ret-tag any, :end-line 842, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first chunk in coll."}, add-tap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11554, :column 7, :end-line 11554, :end-column 14, :arglists (quote ([f])), :doc "Adds f, a fn of one argument, to the tap set. This function will be called with\n  anything sent via tap>. Remember f in order to remove-tap"}, :name cljs.core/add-tap, :file "cljs/core.cljs", :end-column 14, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11554, :ret-tag clj-nil, :end-line 11554, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Adds f, a fn of one argument, to the tap set. This function will be called with\n  anything sent via tap>. Remember f in order to remove-tap"}, filterv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5256, :column 7, :end-line 5256, :end-column 14, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects."}, :name cljs.core/filterv, :file "cljs/core.cljs", :end-column 14, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5256, :ret-tag clj, :end-line 5256, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects."}, ->TaggedLiteral {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 23, :column 10, :factory :positional, :line 11414, :end-line 11414, :arglists (quote ([tag form])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TaggedLiteral."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/->TaggedLiteral, :file "cljs/core.cljs", :end-column 23, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 11414, :ret-tag cljs.core/TaggedLiteral, :end-line 11414, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TaggedLiteral."}, tv-editable-root {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6006, :column 8, :end-line 6006, :end-column 24, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/tv-editable-root, :file "cljs/core.cljs", :end-column 24, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6006, :ret-tag cljs.core/VectorNode, :end-line 6006, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1000, :column 7, :end-line 1000, :end-column 11, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, :name cljs.core/hash, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1000, :ret-tag #{nil number}, :end-line 1000, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, quot {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2851, :column 7, :end-line 2851, :end-column 11, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, :name cljs.core/quot, :file "cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2851, :ret-tag number, :end-line 2851, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, ns-interns* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11644, :column 7, :end-line 11644, :end-column 18, :arglists (quote ([sym])), :doc "Returns a map of the intern mappings for the namespace.\n  Bootstrap only."}, :name cljs.core/ns-interns*, :file "cljs/core.cljs", :end-column 18, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11644, :end-line 11644, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym])), :doc "Returns a map of the intern mappings for the namespace.\n  Bootstrap only."}, unchecked-double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2729, :column 15, :end-line 2729, :end-column 31, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-double, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2729, :ret-tag number, :end-line 2729, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, *target* {:meta {:file "cljs/core.cljs", :line 48, :column 3, :end-line 48, :end-column 11, :dynamic true, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :goog-define "string"}, :name cljs.core/*target*, :file "cljs/core.cljs", :end-column 11, :column 1, :dynamic true, :line 42, :end-line 48, :tag any, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :goog-define "string"}, ->ChunkedCons {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :file "cljs/core.cljs", :end-column 21, :column 10, :factory :positional, :line 3561, :end-line 3561, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/ChunkedCons."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->ChunkedCons, :file "cljs/core.cljs", :end-column 21, :method-params ([chunk more meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 3561, :ret-tag cljs.core/ChunkedCons, :end-line 3561, :max-fixed-arity 4, :fn-var true, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/ChunkedCons."}, ranged-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5469, :column 7, :end-line 5469, :end-column 22, :arglists (quote ([v start end]))}, :name cljs.core/ranged-iterator, :file "cljs/core.cljs", :end-column 22, :method-params ([v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5469, :ret-tag cljs.core/RangedIterator, :end-line 5469, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start end]))}, ITransientVector {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 30, :column 14, :line 817, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :end-line 817, :sigs {:-assoc-n! {:name -assoc-n!, :arglists ([tcoll n val]), :doc "Returns tcoll with value val added at position n."}, :-pop! {:name -pop!, :arglists ([tcoll]), :doc "Returns tcoll with the last item removed from it."}}, :doc "Protocol for adding vector functionality to transient collections.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ITransientVector, :file "cljs/core.cljs", :end-column 30, :column 1, :line 817, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :info nil, :end-line 817, :tag any, :sigs {:-assoc-n! {:name -assoc-n!, :arglists ([tcoll n val]), :doc "Returns tcoll with value val added at position n."}, :-pop! {:name -pop!, :arglists ([tcoll]), :doc "Returns tcoll with the last item removed from it."}}, :impls #{cljs.core/TransientVector}, :doc "Protocol for adding vector functionality to transient collections.", :jsdoc ("@interface")}, key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9025, :column 7, :end-line 9025, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, :name cljs.core/key, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9025, :ret-tag any, :end-line 9025, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, longs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2839, :column 7, :end-line 2839, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/longs, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2839, :end-line 2839, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, not= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4005, :column 16, :end-line 4005, :end-column 20, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/not=, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? true, :tag boolean}], :line 4005, :ret-tag boolean, :end-line 4005, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Same as (not (= obj1 obj2))"}, set-print-err-fn! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 96, :column 7, :end-line 96, :end-column 24, :arglists (quote ([f])), :doc "Set *print-err-fn* to f."}, :name cljs.core/set-print-err-fn!, :file "cljs/core.cljs", :end-column 24, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 96, :end-line 96, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-err-fn* to f."}, string? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 271, :column 16, :end-line 271, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, :name cljs.core/string?, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 271, :ret-tag boolean, :end-line 271, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, uri? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11704, :column 7, :end-line 11704, :end-column 11, :arglists (quote ([x])), :doc "Returns true x is a goog.Uri instance.", :added "1.9"}, :added "1.9", :name cljs.core/uri?, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11704, :ret-tag boolean, :end-line 11704, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true x is a goog.Uri instance."}, es6-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1314, :column 7, :end-line 1314, :end-column 19, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, :name cljs.core/es6-iterator, :file "cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1314, :ret-tag cljs.core/ES6Iterator, :end-line 1314, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, Delay {:num-fields 2, :protocols #{cljs.core/IPending cljs.core/IDeref cljs.core/IPrintWithWriter}, :name cljs.core/Delay, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 10568, :record false, :end-line 10568, :tag function, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref cljs.core/IPrintWithWriter}}, munge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11501, :column 16, :end-line 11501, :end-column 25, :tag string, :private true, :arglists (quote ([name]))}, :private true, :name cljs.core/munge-str, :file "cljs/core.cljs", :end-column 25, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11501, :ret-tag string, :end-line 11501, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([name]))}, pr-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10221, :column 7, :end-line 10221, :end-column 23, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, :name cljs.core/pr-str-with-opts, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10221, :ret-tag string, :end-line 10221, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, ->RecordIter {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 20, :column 10, :factory :positional, :line 6532, :end-line 6532, :arglists (quote ([i record base-count fields ext-map-iter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/RecordIter."}, :protocols #{cljs.core/Object}, :name cljs.core/->RecordIter, :file "cljs/core.cljs", :end-column 20, :method-params ([i record base-count fields ext-map-iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6532, :ret-tag cljs.core/RecordIter, :end-line 6532, :max-fixed-arity 5, :fn-var true, :arglists (quote ([i record base-count fields ext-map-iter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/RecordIter."}, m3-C2 {:name cljs.core/m3-C2, :file "cljs/core.cljs", :line 925, :column 1, :end-line 925, :end-column 11, :meta {:file "cljs/core.cljs", :line 925, :column 6, :end-line 925, :end-column 11}, :tag number}, ->Symbol {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :file "cljs/core.cljs", :end-column 16, :column 10, :factory :positional, :line 1073, :end-line 1073, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/Symbol."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/->Symbol, :file "cljs/core.cljs", :end-column 16, :method-params ([ns name str _hash _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 1073, :ret-tag cljs.core/Symbol, :end-line 1073, :max-fixed-arity 5, :fn-var true, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/Symbol."}, *print-newline* {:meta {:file "cljs/core.cljs", :line 112, :column 3, :end-line 112, :end-column 18, :dynamic true, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, :name cljs.core/*print-newline*, :file "cljs/core.cljs", :end-column 18, :column 1, :dynamic true, :line 107, :end-line 112, :tag any, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, unchecked-multiply-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2775, :column 15, :end-line 2775, :end-column 37, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply-int, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params [[] [x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag number} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2775, :ret-tag number, :end-line 2775, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, tapset {:meta {:file "cljs/core.cljs", :line 11548, :column 3, :end-line 11548, :end-column 9, :jsdoc ["@type {*}"], :private true}, :private true, :name cljs.core/tapset, :file "cljs/core.cljs", :end-column 9, :column 1, :line 11547, :end-line 11548, :tag clj-nil, :jsdoc ["@type {*}"]}, chunk-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3648, :column 7, :end-line 3648, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-rest, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3648, :ret-tag any, :end-line 3648, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, remove-all-methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11233, :column 7, :end-line 11233, :end-column 25, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, :name cljs.core/remove-all-methods, :file "cljs/core.cljs", :end-column 25, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11233, :ret-tag any, :end-line 11233, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, trampoline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10817, :column 7, :end-line 10817, :end-column 17, :arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[f]], :arglists ([f] [f & args]), :arglists-meta (nil nil)}}, :name cljs.core/trampoline, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[f]], :arglists ([f] [f & args]), :arglists-meta (nil nil)}, :method-params [[f]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 1, :variadic? true, :tag any}], :line 10817, :end-line 10817, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & args]), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns."}, double? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2341, :column 7, :end-line 2341, :end-column 14, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, :name cljs.core/double?, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2341, :ret-tag boolean, :end-line 2341, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, pr-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 182, :column 8, :end-line 182, :end-column 15, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/pr-opts, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 182, :ret-tag cljs.core/IMap, :end-line 182, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *1 {:name cljs.core/*1, :file "cljs/core.cljs", :line 205, :column 1, :end-line 207, :end-column 5, :doc "bound in a repl thread to the most recent value printed", :meta {:file "cljs/core.cljs", :line 207, :column 3, :end-line 207, :end-column 5, :doc "bound in a repl thread to the most recent value printed"}}, vec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5717, :column 7, :end-line 5717, :end-column 10, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, :name cljs.core/vec, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5717, :ret-tag #{clj cljs.core/IVector any cljs.core/MetaFn clj-nil}, :end-line 5717, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, ->Cycle {:protocol-inline nil, :meta {:protocols #{cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 15, :column 10, :factory :positional, :line 4848, :end-line 4848, :arglists (quote ([meta all prev current _next])), :skip-protocol-flag #{cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Cycle."}, :protocols #{cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cycle, :file "cljs/core.cljs", :end-column 15, :method-params ([meta all prev current _next]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4848, :ret-tag cljs.core/Cycle, :end-line 4848, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta all prev current _next])), :skip-protocol-flag #{cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Cycle."}, *print-meta* {:meta {:file "cljs/core.cljs", :line 128, :column 3, :end-line 128, :end-column 15, :dynamic true, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, :name cljs.core/*print-meta*, :file "cljs/core.cljs", :end-column 15, :column 1, :dynamic true, :line 122, :end-line 128, :tag any, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, -notify-watches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 786, :column 4, :end-line 786, :end-column 19, :protocol cljs.core/IWatchable, :doc "Calls all watchers with this, oldval and newval.", :arglists (quote ([this oldval newval]))}, :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :file "cljs/core.cljs", :end-column 19, :method-params ([this oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 784, :ret-tag any, :end-line 786, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this oldval newval])), :doc "Calls all watchers with this, oldval and newval."}, MultiFn {:num-fields 8, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/MultiFn, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 11048, :record false, :end-line 11048, :tag function, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, NONE {:name cljs.core/NONE, :file "cljs/core.cljs", :line 4092, :column 1, :end-line 4092, :end-column 20, :private true, :meta {:file "cljs/core.cljs", :line 4092, :column 16, :end-line 4092, :end-column 20, :private true}, :tag object}, int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2812, :column 7, :end-line 2812, :end-column 10, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/int, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2812, :ret-tag number, :end-line 2812, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, ->ValSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 16, :column 10, :factory :positional, :line 9030, :end-line 9030, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/ValSeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ValSeq, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 9030, :ret-tag cljs.core/ValSeq, :end-line 9030, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/ValSeq."}, map-entry? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6744, :column 7, :end-line 6744, :end-column 17, :arglists (quote ([x])), :doc "Returns true if x satisfies IMapEntry"}, :name cljs.core/map-entry?, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6744, :ret-tag boolean, :end-line 6744, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies IMapEntry"}, rand {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10833, :column 7, :end-line 10833, :end-column 11, :arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [n]], :arglists ([] [n]), :arglists-meta (nil nil)}}, :name cljs.core/rand, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [n]], :arglists ([] [n]), :arglists-meta (nil nil)}, :method-params [[] [n]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 0, :variadic? false, :tag any} {:fixed-arity 1, :variadic? false, :tag number}], :line 10833, :end-line 10833, :max-fixed-arity 1, :fn-var true, :arglists ([] [n]), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive)."}, second {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1757, :column 7, :end-line 1757, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/second, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1757, :ret-tag #{any clj-nil}, :end-line 1757, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, find-ns-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11621, :column 7, :end-line 11621, :end-column 18, :arglists (quote ([ns])), :doc "Bootstrap only."}, :name cljs.core/find-ns-obj, :file "cljs/core.cljs", :end-column 18, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11621, :end-line 11621, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns])), :doc "Bootstrap only."}, IEditableCollection {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 33, :column 14, :line 794, :protocol-info {:methods {-as-transient [[coll]]}}, :end-line 794, :sigs {:-as-transient {:name -as-transient, :arglists ([coll]), :doc "Returns a new, transient version of the collection, in constant time."}}, :doc "Protocol for collections which can transformed to transients.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IEditableCollection, :file "cljs/core.cljs", :end-column 33, :column 1, :line 794, :protocol-info {:methods {-as-transient [[coll]]}}, :info nil, :end-line 794, :tag any, :sigs {:-as-transient {:name -as-transient, :arglists ([coll]), :doc "Returns a new, transient version of the collection, in constant time."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentHashSet}, :doc "Protocol for collections which can transformed to transients.", :jsdoc ("@interface")}, hash-combine {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1036, :column 7, :end-line 1036, :end-column 19, :arglists (quote ([seed hash]))}, :name cljs.core/hash-combine, :file "cljs/core.cljs", :end-column 19, :method-params ([seed hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1036, :ret-tag number, :end-line 1036, :max-fixed-arity 2, :fn-var true, :arglists (quote ([seed hash]))}, > {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2669, :column 16, :end-line 2669, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? true, :tag boolean}], :line 2669, :ret-tag boolean, :end-line 2669, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false."}, -name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 854, :column 12, :end-line 854, :end-column 17, :tag string, :protocol cljs.core/INamed, :doc "Returns the name String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-name, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 852, :ret-tag string, :end-line 854, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of x."}, replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9466, :column 7, :end-line 9466, :end-column 14, :arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[smap] [smap coll]], :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}}, :name cljs.core/replace, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[smap] [smap coll]], :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}, :method-params [[smap] [smap coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag #{nil any cljs.core/LazySeq}}], :line 9466, :end-line 9466, :max-fixed-arity 2, :fn-var true, :arglists ([smap] [smap coll]), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided."}, int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2283, :column 7, :end-line 2283, :end-column 11, :arglists (quote ([x])), :doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long."}, :name cljs.core/int?, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2283, :ret-tag boolean, :end-line 2283, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long."}, ->Subvec {:protocol-inline nil, :meta {:protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 16, :column 10, :factory :positional, :line 5840, :end-line 5840, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Subvec."}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->Subvec, :file "cljs/core.cljs", :end-column 16, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 5840, :ret-tag cljs.core/Subvec, :end-line 5840, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Subvec."}, associative? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2147, :column 7, :end-line 2147, :end-column 19, :arglists (quote ([x])), :doc "Returns true if coll implements IAssociative"}, :name cljs.core/associative?, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2147, :ret-tag boolean, :end-line 2147, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements IAssociative"}, unchecked-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2817, :column 7, :end-line 2817, :end-column 20, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/unchecked-int, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2817, :ret-tag number, :end-line 2817, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, js-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2198, :column 7, :end-line 2198, :end-column 14, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, :name cljs.core/js-keys, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2198, :ret-tag array, :end-line 2198, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, inst-ms* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1404, :column 4, :end-line 1404, :end-column 12, :protocol cljs.core/Inst, :doc nil, :arglists (quote ([inst]))}, :protocol cljs.core/Inst, :name cljs.core/inst-ms*, :file "cljs/core.cljs", :end-column 12, :method-params ([inst]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1403, :ret-tag any, :end-line 1404, :max-fixed-arity 1, :fn-var true, :arglists (quote ([inst])), :doc nil}, ES6EntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6EntriesIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6545, :record false, :end-line 6545, :tag function, :skip-protocol-flag nil}, keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3346, :column 7, :end-line 3346, :end-column 15, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, :name cljs.core/keyword?, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3346, :ret-tag boolean, :end-line 3346, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, array-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4044, :column 7, :end-line 4044, :end-column 17, :arglists (quote ([x]))}, :name cljs.core/array-iter, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4044, :ret-tag cljs.core/ArrayIter, :end-line 4044, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, force {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10590, :column 7, :end-line 10590, :end-column 12, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, :name cljs.core/force, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10590, :ret-tag #{nil any}, :end-line 10590, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, group-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10850, :column 7, :end-line 10850, :end-column 15, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, :name cljs.core/group-by, :file "cljs/core.cljs", :end-column 15, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10850, :ret-tag clj, :end-line 10850, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, *global* {:meta {:file "cljs/core.cljs", :line 54, :column 3, :end-line 54, :end-column 11, :dynamic true, :doc "Manually set the JavaScript global context. Only \"window\", \"self\"\n  , and \"global\" supported. ", :goog-define "string"}, :name cljs.core/*global*, :file "cljs/core.cljs", :end-column 11, :column 1, :dynamic true, :line 50, :end-line 54, :tag any, :doc "Manually set the JavaScript global context. Only \"window\", \"self\"\n  , and \"global\" supported. ", :goog-define "string"}, -rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 743, :column 9, :end-line 743, :end-column 14, :tag clj, :protocol cljs.core/IReversible, :doc "Returns a seq of the items in coll in reversed order.", :arglists (quote ([coll]))}, :protocol cljs.core/IReversible, :name cljs.core/-rseq, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 741, :ret-tag clj, :end-line 743, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reversed order."}, prn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10294, :column 7, :end-line 10294, :end-column 10, :arglists (quote ([& objs])), :doc "Same as pr followed by (newline).", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag clj-nil}], :line 10294, :ret-tag any, :end-line 10294, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr followed by (newline)."}, tv-pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6026, :column 8, :end-line 6026, :end-column 19, :private true, :arglists (quote ([tv level node]))}, :private true, :name cljs.core/tv-pop-tail, :file "cljs/core.cljs", :end-column 19, :method-params ([tv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6026, :ret-tag #{nil cljs.core/VectorNode clj-nil}, :end-line 6026, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tv level node]))}, default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11262, :column 7, :end-line 11262, :end-column 27, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, :name cljs.core/default-dispatch-val, :file "cljs/core.cljs", :end-column 27, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11262, :ret-tag any, :end-line 11262, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, RangeChunk {:num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/ISeq cljs.core/IChunk}, :name cljs.core/RangeChunk, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 9653, :record false, :end-line 9653, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/ISeq}}, ->Atom {:protocol-inline nil, :meta {:protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :file "cljs/core.cljs", :end-column 14, :column 10, :factory :positional, :line 4431, :end-line 4431, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :doc "Positional factory function for cljs.core/Atom."}, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Atom, :file "cljs/core.cljs", :end-column 14, :method-params ([state meta validator watches]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4431, :ret-tag cljs.core/Atom, :end-line 4431, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :doc "Positional factory function for cljs.core/Atom."}, js-iterable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1208, :column 7, :end-line 1208, :end-column 19, :arglists (quote ([x])), :doc "Return true if x has a JavaScript iterator property"}, :name cljs.core/js-iterable?, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1208, :ret-tag boolean, :end-line 1208, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x has a JavaScript iterator property"}, PersistentHashMap {:meta {:file "cljs/core.cljs", :line 1991, :column 10, :end-line 1991, :end-column 27, :declared true}, :num-fields 6, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentHashMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7872, :record false, :declared true, :end-line 7872, :tag function, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unchecked-multiply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2768, :column 15, :end-line 2768, :end-column 33, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params [[] [x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag number} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2768, :ret-tag number, :end-line 2768, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, ArrayNodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ArrayNodeSeq, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 7790, :record false, :end-line 7790, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, even? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4262, :column 7, :end-line 4262, :end-column 12, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, :name cljs.core/even?, :file "cljs/core.cljs", :end-column 12, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4262, :ret-tag boolean, :end-line 4262, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, es6-iterator-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1329, :column 7, :end-line 1329, :end-column 23, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, :name cljs.core/es6-iterator-seq, :file "cljs/core.cljs", :end-column 23, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1329, :ret-tag #{cljs.core/ES6IteratorSeq clj-nil}, :end-line 1329, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, unchecked-dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2745, :column 7, :end-line 2745, :end-column 20, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2745, :ret-tag number, :end-line 2745, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, Inst {:meta {:file "cljs/core.cljs", :line 1403, :column 14, :end-line 1403, :end-column 18, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {inst-ms* [[inst]]}}, :sigs {:inst-ms* {:name inst-ms*, :arglists ([inst]), :doc nil}}}, :protocol-symbol true, :name cljs.core/Inst, :file "cljs/core.cljs", :end-column 18, :column 1, :line 1403, :protocol-info {:methods {inst-ms* [[inst]]}}, :info nil, :end-line 1403, :tag any, :sigs {:inst-ms* {:name inst-ms*, :arglists ([inst]), :doc nil}}, :impls #{js/Date}, :jsdoc ("@interface")}, hash-collision-node-find-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7580, :column 8, :end-line 7580, :end-column 38, :private true, :arglists (quote ([arr cnt key]))}, :private true, :name cljs.core/hash-collision-node-find-index, :file "cljs/core.cljs", :end-column 38, :method-params ([arr cnt key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 7580, :ret-tag number, :end-line 7580, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr cnt key]))}, persistent-array-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6814, :column 7, :end-line 6814, :end-column 31, :arglists (quote ([arr i _meta]))}, :name cljs.core/persistent-array-map-seq, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6814, :ret-tag #{cljs.core/PersistentArrayMapSeq clj-nil}, :end-line 6814, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta]))}, RangeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/RangeIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 9674, :record false, :end-line 9674, :tag function, :skip-protocol-flag nil}, tagged-literal? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11444, :column 7, :end-line 11444, :end-column 22, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, :name cljs.core/tagged-literal?, :file "cljs/core.cljs", :end-column 22, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11444, :ret-tag boolean, :end-line 11444, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, double-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3723, :column 7, :end-line 3723, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size-or-seq] [size init-val-or-seq]], :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/double-array, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size-or-seq] [size init-val-or-seq]], :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params [[size-or-seq] [size init-val-or-seq]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag #{any array}} {:fixed-arity 2, :variadic? false, :tag array}], :line 3723, :end-line 3723, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure."}, create-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11657, :column 7, :end-line 11657, :end-column 16, :arglists (quote ([sym] [sym ns-obj])), :doc "Create a new namespace named by the symbol. Bootstrap only.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[sym] [sym ns-obj]], :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}}, :name cljs.core/create-ns, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[sym] [sym ns-obj]], :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}, :method-params [[sym] [sym ns-obj]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag cljs.core/Namespace}], :line 11657, :end-line 11657, :max-fixed-arity 2, :fn-var true, :arglists ([sym] [sym ns-obj]), :doc "Create a new namespace named by the symbol. Bootstrap only."}, ->EmptyList {:protocol-inline nil, :meta {:protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 19, :column 10, :factory :positional, :line 3129, :end-line 3129, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/EmptyList."}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->EmptyList, :file "cljs/core.cljs", :end-column 19, :method-params ([meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 3129, :ret-tag cljs.core/EmptyList, :end-line 3129, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/EmptyList."}, seq-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2474, :column 8, :end-line 2474, :end-column 18, :private true, :arglists (quote ([f coll] [f val coll])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[f coll] [f val coll]], :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/seq-reduce, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[f coll] [f val coll]], :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params [[f coll] [f val coll]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag #{nil any}} {:fixed-arity 3, :variadic? false, :tag #{nil any}}], :line 2474, :end-line 2474, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll])}, spread {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3779, :column 7, :end-line 3779, :end-column 13, :arglists (quote ([arglist]))}, :name cljs.core/spread, :file "cljs/core.cljs", :end-column 13, :method-params ([arglist]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3779, :ret-tag #{seq clj clj-nil}, :end-line 3779, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist]))}, balance-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8250, :column 8, :end-line 8250, :end-column 20, :private true, :arglists (quote ([key val ins right]))}, :private true, :name cljs.core/balance-left, :file "cljs/core.cljs", :end-column 20, :method-params ([key val ins right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8250, :ret-tag clj, :end-line 8250, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val ins right]))}, rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3205, :column 12, :end-line 3205, :end-column 16, :tag seq, :arglists (quote ([rev])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, :name cljs.core/rseq, :file "cljs/core.cljs", :end-column 16, :method-params ([rev]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3205, :ret-tag seq, :end-line 3205, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([rev])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, ex-cause {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11382, :column 7, :end-line 11382, :end-column 15, :arglists (quote ([ex])), :doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-cause, :file "cljs/core.cljs", :end-column 15, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11382, :ret-tag #{any clj-nil}, :end-line 11382, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, IReset {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 20, :column 14, :line 862, :protocol-info {:methods {-reset! [[o new-value]]}}, :end-line 862, :sigs {:-reset! {:name -reset!, :arglists ([o new-value]), :doc "Sets the value of o to new-value."}}, :doc "Protocol for adding resetting functionality.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IReset, :file "cljs/core.cljs", :end-column 20, :column 1, :line 862, :protocol-info {:methods {-reset! [[o new-value]]}}, :info nil, :end-line 862, :tag any, :sigs {:-reset! {:name -reset!, :arglists ([o new-value]), :doc "Sets the value of o to new-value."}}, :impls #{}, :doc "Protocol for adding resetting functionality.", :jsdoc ("@interface")}, IEmptyableCollection {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 34, :column 14, :line 588, :protocol-info {:methods {-empty [[coll]]}}, :end-line 588, :sigs {:-empty {:name -empty, :arglists ([coll]), :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty."}}, :doc "Protocol for creating an empty collection.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IEmptyableCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 588, :protocol-info {:methods {-empty [[coll]]}}, :info nil, :end-line 588, :tag any, :sigs {:-empty {:name -empty, :arglists ([coll]), :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/Cycle cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/Iterate cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for creating an empty collection.", :jsdoc ("@interface")}, array-map-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6630, :column 8, :end-line 6630, :end-column 26, :private true, :arglists (quote ([m k]))}, :private true, :name cljs.core/array-map-index-of, :file "cljs/core.cljs", :end-column 26, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6630, :ret-tag number, :end-line 6630, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k]))}, ex-message {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11375, :column 7, :end-line 11375, :end-column 17, :arglists (quote ([ex])), :doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, :name cljs.core/ex-message, :file "cljs/core.cljs", :end-column 17, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11375, :ret-tag #{any clj-nil}, :end-line 11375, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, ->NodeIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 23, :column 11, :factory :positional, :line 7206, :end-line 7206, :arglists (quote ([arr i next-entry next-iter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/NodeIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->NodeIterator, :file "cljs/core.cljs", :end-column 23, :method-params ([arr i next-entry next-iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 2, :variadic? false, :factory :positional, :line 7206, :ret-tag cljs.core/NodeIterator, :end-line 7206, :max-fixed-arity 4, :fn-var true, :arglists (quote ([arr i next-entry next-iter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/NodeIterator."}, *print-fn-bodies* {:meta {:file "cljs/core.cljs", :line 175, :column 3, :end-line 175, :end-column 20, :dynamic true, :doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, :name cljs.core/*print-fn-bodies*, :file "cljs/core.cljs", :end-column 20, :column 1, :dynamic true, :line 171, :end-line 175, :tag any, :doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, string-print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10074, :column 7, :end-line 10074, :end-column 19, :arglists (quote ([x]))}, :name cljs.core/string-print, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10074, :ret-tag clj-nil, :end-line 10074, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2722, :column 15, :end-line 2722, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/float, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2722, :ret-tag number, :end-line 2722, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, IRecord {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 21, :column 14, :line 738, :protocol-info {:methods {}}, :end-line 738, :sigs {}, :doc "Marker interface indicating a record object", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IRecord, :file "cljs/core.cljs", :end-column 21, :column 1, :line 738, :protocol-info {:methods {}}, :info nil, :end-line 738, :tag any, :sigs {}, :impls #{}, :doc "Marker interface indicating a record object", :jsdoc ("@interface")}, pr-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10252, :column 7, :end-line 10252, :end-column 13, :arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr-str, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag string}], :line 10252, :ret-tag any, :end-line 10252, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."}, first-array-for-longvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5409, :column 8, :end-line 5409, :end-column 31, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/first-array-for-longvec, :file "cljs/core.cljs", :end-column 31, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5409, :ret-tag any, :end-line 5409, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, es6-set-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6567, :column 7, :end-line 6567, :end-column 31, :arglists (quote ([coll]))}, :name cljs.core/es6-set-entries-iterator, :file "cljs/core.cljs", :end-column 31, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6567, :ret-tag cljs.core/ES6SetEntriesIterator, :end-line 6567, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, concat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3788, :column 7, :end-line 3788, :end-column 13, :arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/concat, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}, :method-params [[] [x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 1, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 2, :variadic? true, :tag cljs.core/LazySeq}], :line 3788, :end-line 3788, :max-fixed-arity 2, :fn-var true, :arglists ([] [x] [x y] [x y & zs]), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls."}, -methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11040, :column 4, :end-line 11040, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11034, :ret-tag any, :end-line 11040, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, js-reserved {:name cljs.core/js-reserved, :file "cljs/core.cljs", :line 11474, :column 1, :end-line 11476, :end-column 14, :jsdoc ["@type {null|Object}"], :meta {:file "cljs/core.cljs", :line 11476, :column 3, :end-line 11476, :end-column 14, :jsdoc ["@type {null|Object}"]}, :tag clj-nil}, IDerefWithTimeout {:meta {:file "cljs/core.cljs", :line 689, :column 14, :end-line 689, :end-column 31, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :sigs {:-deref-with-timeout {:name -deref-with-timeout, :arglists ([o msec timeout-val]), :doc nil}}}, :protocol-symbol true, :name cljs.core/IDerefWithTimeout, :file "cljs/core.cljs", :end-column 31, :column 1, :line 689, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :info nil, :end-line 689, :tag any, :sigs {:-deref-with-timeout {:name -deref-with-timeout, :arglists ([o msec timeout-val]), :doc nil}}, :impls #{}, :jsdoc ("@interface")}, symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1112, :column 7, :end-line 1112, :end-column 13, :arglists (quote ([name] [ns name])), :doc "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[name] [ns name]], :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/symbol, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[name] [ns name]], :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params [[name] [ns name]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag #{any cljs.core/Symbol}} {:fixed-arity 2, :variadic? false, :tag cljs.core/Symbol}], :line 1112, :end-line 1112, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name]), :doc "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars."}, to-array-2d {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3668, :column 7, :end-line 3668, :end-column 18, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, :name cljs.core/to-array-2d, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3668, :ret-tag array, :end-line 3668, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, Subvec {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/Subvec, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 5840, :record false, :end-line 5840, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ExceptionInfo {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11333, :column 3, :end-line 11333, :end-column 16, :jsdoc ["@constructor"], :arglists (quote ([message data cause]))}, :name cljs.core/ExceptionInfo, :file "cljs/core.cljs", :end-column 16, :method-params ([message data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11332, :ret-tag any, :end-line 11333, :max-fixed-arity 3, :fn-var true, :arglists (quote ([message data cause])), :jsdoc ["@constructor"]}, mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2846, :column 7, :end-line 2846, :end-column 10, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, :name cljs.core/mod, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2846, :ret-tag number, :end-line 2846, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, ISet {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 18, :column 14, :line 664, :protocol-info {:methods {-disjoin [[coll v]]}}, :end-line 664, :sigs {:-disjoin {:name -disjoin, :arglists ([coll v]), :doc "Returns a new collection of coll that does not contain v."}}, :doc "Protocol for adding set functionality to a collection.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ISet, :file "cljs/core.cljs", :end-column 18, :column 1, :line 664, :protocol-info {:methods {-disjoin [[coll v]]}}, :info nil, :end-line 664, :tag any, :sigs {:-disjoin {:name -disjoin, :arglists ([coll v]), :doc "Returns a new collection of coll that does not contain v."}}, :impls #{cljs.core/PersistentHashSet cljs.core/PersistentTreeSet}, :doc "Protocol for adding set functionality to a collection.", :jsdoc ("@interface")}, pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2105, :column 7, :end-line 2105, :end-column 10, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, :name cljs.core/pop, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2105, :ret-tag #{clj clj-nil}, :end-line 2105, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, IPending {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 22, :column 14, :line 778, :protocol-info {:methods {-realized? [[x]]}}, :end-line 778, :sigs {:-realized? {:name -realized?, :arglists ([x]), :doc "Returns true if a value for x has been produced, false otherwise."}}, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IPending, :file "cljs/core.cljs", :end-column 22, :column 1, :line 778, :protocol-info {:methods {-realized? [[x]]}}, :info nil, :end-line 778, :tag any, :sigs {:-realized? {:name -realized?, :arglists ([x]), :doc "Returns true if a value for x has been produced, false otherwise."}}, :impls #{cljs.core/Delay cljs.core/LazySeq cljs.core/Cycle cljs.core/Repeat cljs.core/Iterate}, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :jsdoc ("@interface")}, t_cljs$core11293 {:num-fields 1, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t_cljs$core11293, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 4017, :record false, :tag function, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, -entry-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 758, :column 4, :end-line 758, :end-column 14, :protocol cljs.core/ISorted, :doc "Returns the key for entry.", :arglists (quote ([coll entry]))}, :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :file "cljs/core.cljs", :end-column 14, :method-params ([coll entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 746, :ret-tag any, :end-line 758, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll entry])), :doc "Returns the key for entry."}, CHAR_MAP {:name cljs.core/CHAR_MAP, :file "cljs/core.cljs", :line 341, :column 1, :end-line 342, :end-column 11, :jsdoc ["@enum {string}"], :meta {:file "cljs/core.cljs", :line 342, :column 3, :end-line 342, :end-column 11, :jsdoc ["@enum {string}"]}, :tag object}, pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5443, :column 8, :end-line 5443, :end-column 16, :private true, :arglists (quote ([pv level node]))}, :private true, :name cljs.core/pop-tail, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5443, :ret-tag #{cljs.core/VectorNode clj-nil}, :end-line 5443, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pv level node]))}, dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3863, :column 7, :end-line 3863, :end-column 14, :arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s).", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tcoll key]], :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}}, :name cljs.core/dissoc!, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tcoll key]], :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}, :method-params [[tcoll key]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag clj} {:fixed-arity 2, :variadic? true, :tag clj}], :line 3863, :end-line 3863, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll key] [tcoll key & ks]), :doc "Returns a transient map that doesn't contain a mapping for key(s)."}, reductions {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9901, :column 7, :end-line 9901, :end-column 17, :arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[f coll] [f init coll]], :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/reductions, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[f coll] [f init coll]], :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}, :method-params [[f coll] [f init coll]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 3, :variadic? false, :tag clj}], :line 9901, :end-line 9901, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f init coll]), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init."}, indexed? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1538, :column 7, :end-line 1538, :end-column 15, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, :name cljs.core/indexed?, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1538, :ret-tag boolean, :end-line 1538, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, - {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2622, :column 15, :end-line 2622, :end-column 16, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/-, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag number} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2622, :ret-tag number, :end-line 2622, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, Cycle {:num-fields 5, :protocols #{cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cycle, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 4848, :record false, :end-line 4848, :tag function, :skip-protocol-flag #{cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -equiv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 719, :column 13, :end-line 719, :end-column 19, :tag boolean, :protocol cljs.core/IEquiv, :doc "Returns true if o and other are equal, false otherwise.", :arglists (quote ([o other]))}, :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :file "cljs/core.cljs", :end-column 19, :method-params ([o other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 717, :ret-tag boolean, :end-line 719, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([o other])), :doc "Returns true if o and other are equal, false otherwise."}, ->RangeIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 23, :column 10, :factory :positional, :line 9674, :end-line 9674, :arglists (quote ([i end step])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/RangeIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->RangeIterator, :file "cljs/core.cljs", :end-column 23, :method-params ([i end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 9674, :ret-tag cljs.core/RangeIterator, :end-line 9674, :max-fixed-arity 3, :fn-var true, :arglists (quote ([i end step])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/RangeIterator."}, ->ArrayNode {:protocol-inline nil, :meta {:protocols #{cljs.core/Object cljs.core/IIterable}, :file "cljs/core.cljs", :end-column 19, :column 10, :factory :positional, :line 7479, :end-line 7479, :arglists (quote ([edit cnt arr])), :skip-protocol-flag #{cljs.core/IIterable}, :doc "Positional factory function for cljs.core/ArrayNode."}, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/->ArrayNode, :file "cljs/core.cljs", :end-column 19, :method-params ([edit cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7479, :ret-tag cljs.core/ArrayNode, :end-line 7479, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit cnt arr])), :skip-protocol-flag #{cljs.core/IIterable}, :doc "Positional factory function for cljs.core/ArrayNode."}, assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3851, :column 7, :end-line 3851, :end-column 13, :arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[tcoll key val]], :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc!, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[tcoll key val]], :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}, :method-params [[tcoll key val]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 3, :variadic? false, :tag clj} {:fixed-arity 3, :variadic? true, :tag clj}], :line 3851, :end-line 3851, :max-fixed-arity 3, :fn-var true, :arglists ([tcoll key val] [tcoll key val & kvs]), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll."}, hash-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9448, :column 7, :end-line 9448, :end-column 15, :arglists (quote ([] [& keys])), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [[]], :arglists ([] [& keys]), :arglists-meta (nil nil)}}, :name cljs.core/hash-set, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [[]], :arglists ([] [& keys]), :arglists-meta (nil nil)}, :method-params [[]], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag cljs.core/ISet} {:fixed-arity 0, :variadic? true, :tag #{clj any cljs.core/ISet cljs.core/MetaFn clj-nil}}], :line 9448, :end-line 9448, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keys]), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj."}, reduce-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2569, :column 7, :end-line 2569, :end-column 16, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, :name cljs.core/reduce-kv, :file "cljs/core.cljs", :end-column 16, :method-params ([f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2569, :ret-tag #{nil any}, :end-line 2569, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, reset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4479, :column 7, :end-line 4479, :end-column 13, :arglists (quote ([a new-value])), :doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value."}, :name cljs.core/reset!, :file "cljs/core.cljs", :end-column 13, :method-params ([a new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4479, :ret-tag #{nil any}, :end-line 4479, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a new-value])), :doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value."}, name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9517, :column 7, :end-line 9517, :end-column 11, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, :name cljs.core/name, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9517, :ret-tag string, :end-line 9517, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, ->RedNode {:protocol-inline nil, :meta {:protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 17, :column 10, :factory :positional, :line 8473, :end-line 8473, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/RedNode."}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->RedNode, :file "cljs/core.cljs", :end-column 17, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 8473, :ret-tag cljs.core/RedNode, :end-line 8473, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/RedNode."}, unchecked-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5417, :column 8, :end-line 5417, :end-column 27, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/unchecked-array-for, :file "cljs/core.cljs", :end-column 27, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5417, :ret-tag any, :end-line 5417, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, Fn {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 16, :column 14, :line 547, :protocol-info {:methods {}}, :end-line 547, :sigs {}, :doc "Marker protocol", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/Fn, :file "cljs/core.cljs", :end-column 16, :column 1, :line 547, :protocol-info {:methods {}}, :info nil, :end-line 547, :tag any, :sigs {}, :impls #{cljs.core/Var function cljs.core/MetaFn}, :doc "Marker protocol", :jsdoc ("@interface")}, ffirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1762, :column 7, :end-line 1762, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, :name cljs.core/ffirst, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1762, :ret-tag #{any clj-nil}, :end-line 1762, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, ->ArrayNodeIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 27, :column 10, :factory :positional, :line 7459, :end-line 7459, :arglists (quote ([arr i next-iter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ArrayNodeIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayNodeIterator, :file "cljs/core.cljs", :end-column 27, :method-params ([arr i next-iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7459, :ret-tag cljs.core/ArrayNodeIterator, :end-line 7459, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i next-iter])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ArrayNodeIterator."}, sorted-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9454, :column 7, :end-line 9454, :end-column 17, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}, :method-params [(keys)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag #{nil any}}], :line 9454, :ret-tag any, :end-line 9454, :max-fixed-arity 0, :fn-var true, :arglists ([& keys]), :doc "Returns a new sorted set with supplied keys."}, pr-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10238, :column 8, :end-line 10238, :end-column 20, :private true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, :private true, :name cljs.core/pr-with-opts, :file "cljs/core.cljs", :end-column 20, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10238, :ret-tag clj-nil, :end-line 10238, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, PersistentTreeMap {:num-fields 5, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentTreeMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 8744, :record false, :end-line 8744, :tag function, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, strip-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10301, :column 8, :end-line 10301, :end-column 16, :private true, :arglists (quote ([named]))}, :private true, :name cljs.core/strip-ns, :file "cljs/core.cljs", :end-column 16, :method-params ([named]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10301, :ret-tag clj, :end-line 10301, :max-fixed-arity 1, :fn-var true, :arglists (quote ([named]))}, ->PersistentTreeMap {:protocol-inline nil, :meta {:protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 27, :column 10, :factory :positional, :line 8744, :end-line 8744, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "Positional factory function for cljs.core/PersistentTreeMap."}, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentTreeMap, :file "cljs/core.cljs", :end-column 27, :method-params ([comp tree cnt meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 8744, :ret-tag cljs.core/PersistentTreeMap, :end-line 8744, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "Positional factory function for cljs.core/PersistentTreeMap."}, array-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1501, :column 8, :end-line 1501, :end-column 20, :private true, :arglists (quote ([arr f] [arr f val] [arr f val idx])), :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[arr f] [arr f val] [arr f val idx]], :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}}, :private true, :name cljs.core/array-reduce, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[arr f] [arr f val] [arr f val idx]], :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}, :method-params [[arr f] [arr f val] [arr f val idx]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag #{nil any}} {:fixed-arity 4, :variadic? false, :tag #{nil any}}], :line 1501, :end-line 1501, :max-fixed-arity 4, :fn-var true, :arglists ([arr f] [arr f val] [arr f val idx])}, counted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1534, :column 7, :end-line 1534, :end-column 15, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, :name cljs.core/counted?, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1534, :ret-tag boolean, :end-line 1534, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, tagged-literal {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11449, :column 7, :end-line 11449, :end-column 21, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, :name cljs.core/tagged-literal, :file "cljs/core.cljs", :end-column 21, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11449, :ret-tag cljs.core/TaggedLiteral, :end-line 11449, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, println {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10282, :column 7, :end-line 10282, :end-column 14, :arglists (quote ([& objs])), :doc "Same as print followed by (newline)", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag clj-nil}], :line 10282, :ret-tag any, :end-line 10282, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as print followed by (newline)"}, assoc-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5306, :column 7, :end-line 5306, :end-column 15, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, :name cljs.core/assoc-in, :file "cljs/core.cljs", :end-column 15, :method-params ([m p__11777 v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5306, :ret-tag #{clj any}, :end-line 5306, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, PersistentHashSet {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentHashSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 9161, :record false, :end-line 9161, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}}, bit-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2906, :column 16, :end-line 2906, :end-column 24, :tag boolean, :arglists (quote ([x n])), :doc "Test bit at index n"}, :name cljs.core/bit-test, :file "cljs/core.cljs", :end-column 24, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2906, :ret-tag boolean, :end-line 2906, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x n])), :doc "Test bit at index n"}, ->Namespace {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :file "cljs/core.cljs", :end-column 19, :column 10, :factory :positional, :line 11589, :end-line 11589, :arglists (quote ([obj name])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}, :doc "Positional factory function for cljs.core/Namespace."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/->Namespace, :file "cljs/core.cljs", :end-column 19, :method-params ([obj name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 11589, :ret-tag cljs.core/Namespace, :end-line 11589, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj name])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}, :doc "Positional factory function for cljs.core/Namespace."}, TransientHashMap {:meta {:file "cljs/core.cljs", :line 7132, :column 10, :end-line 7132, :end-column 26, :declared true}, :num-fields 5, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientHashMap, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 8050, :record false, :declared true, :end-line 8050, :tag function, :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->PersistentHashMap {:protocol-inline nil, :meta {:protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 27, :column 10, :factory :positional, :line 7872, :end-line 7872, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "Positional factory function for cljs.core/PersistentHashMap."}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentHashMap, :file "cljs/core.cljs", :end-column 27, :method-params ([meta cnt root has-nil? nil-val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7872, :ret-tag cljs.core/PersistentHashMap, :end-line 7872, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "Positional factory function for cljs.core/PersistentHashMap."}, array-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6633, :column 8, :end-line 6633, :end-column 23, :private true, :arglists (quote ([arr k v]))}, :private true, :name cljs.core/array-extend-kv, :file "cljs/core.cljs", :end-column 23, :method-params ([arr k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6633, :ret-tag array, :end-line 6633, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr k v]))}, ISwap {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 19, :column 14, :line 867, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :end-line 867, :sigs {:-swap! {:name -swap!, :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :doc "Swaps the value of o to be (apply f current-value-of-atom args)."}}, :doc "Protocol for adding swapping functionality.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ISwap, :file "cljs/core.cljs", :end-column 19, :column 1, :line 867, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :info nil, :end-line 867, :tag any, :sigs {:-swap! {:name -swap!, :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :doc "Swaps the value of o to be (apply f current-value-of-atom args)."}}, :impls #{}, :doc "Protocol for adding swapping functionality.", :jsdoc ("@interface")}, ChunkedCons {:meta {:file "cljs/core.cljs", :line 2183, :column 10, :end-line 2183, :end-column 21, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/ChunkedCons, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3561, :record false, :declared true, :end-line 3561, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, memoize {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10802, :column 7, :end-line 10802, :end-column 14, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, :name cljs.core/memoize, :file "cljs/core.cljs", :end-column 14, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10802, :ret-tag function, :end-line 10802, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, alter-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10507, :column 7, :end-line 10507, :end-column 18, :arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}}, :name cljs.core/alter-meta!, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}, :method-params [(iref f args)], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? true}], :line 10507, :ret-tag any, :end-line 10507, :max-fixed-arity 2, :fn-var true, :arglists ([iref f & args]), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects"}, ->StringBufferWriter {:protocol-inline nil, :meta {:protocols #{cljs.core/IWriter}, :file "cljs/core.cljs", :end-column 28, :column 10, :factory :positional, :line 885, :end-line 885, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}, :doc "Positional factory function for cljs.core/StringBufferWriter."}, :protocols #{cljs.core/IWriter}, :name cljs.core/->StringBufferWriter, :file "cljs/core.cljs", :end-column 28, :method-params ([sb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 885, :ret-tag cljs.core/StringBufferWriter, :end-line 885, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}, :doc "Positional factory function for cljs.core/StringBufferWriter."}, zero? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2951, :column 16, :end-line 2951, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is zero, else false"}, :name cljs.core/zero?, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2951, :ret-tag boolean, :end-line 2951, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is zero, else false"}, tv-ensure-editable {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6001, :column 8, :end-line 6001, :end-column 26, :private true, :arglists (quote ([edit node]))}, :private true, :name cljs.core/tv-ensure-editable, :file "cljs/core.cljs", :end-column 26, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6001, :ret-tag #{nil cljs.core/VectorNode}, :end-line 6001, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, simple-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3396, :column 7, :end-line 3396, :end-column 22, :arglists (quote ([x])), :doc "Return true if x is a keyword without a namespace"}, :name cljs.core/simple-keyword?, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3396, :ret-tag boolean, :end-line 3396, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a keyword without a namespace"}, -indexOf {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1542, :column 8, :end-line 1542, :end-column 16, :private true, :arglists (quote ([coll x] [coll x start])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll x] [coll x start]], :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/-indexOf, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll x] [coll x start]], :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}, :method-params [[coll x] [coll x start]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag #{any number}}], :line 1542, :end-line 1542, :max-fixed-arity 3, :fn-var true, :arglists ([coll x] [coll x start])}, *main-cli-fn* {:name cljs.core/*main-cli-fn*, :file "cljs/core.cljs", :line 300, :column 1, :end-line 304, :end-column 16, :doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments", :meta {:file "cljs/core.cljs", :line 304, :column 3, :end-line 304, :end-column 16, :doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}, :tag clj-nil}, -assoc-n {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 681, :column 9, :end-line 681, :end-column 17, :tag clj, :protocol cljs.core/IVector, :doc "Returns a new vector with value val added at position n.", :arglists (quote ([coll n val]))}, :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :file "cljs/core.cljs", :end-column 17, :method-params ([coll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 679, :ret-tag clj, :end-line 681, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll n val])), :doc "Returns a new vector with value val added at position n."}, unchecked-dec-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2750, :column 7, :end-line 2750, :end-column 24, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec-int, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2750, :ret-tag number, :end-line 2750, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, hash-imap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3019, :column 8, :end-line 3019, :end-column 17, :private true, :arglists (quote ([m]))}, :private true, :name cljs.core/hash-imap, :file "cljs/core.cljs", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3019, :ret-tag number, :end-line 3019, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, dominates {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11002, :column 8, :end-line 11002, :end-column 17, :private true, :arglists (quote ([x y prefer-table hierarchy]))}, :private true, :name cljs.core/dominates, :file "cljs/core.cljs", :end-column 17, :method-params ([x y prefer-table hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11002, :ret-tag boolean, :end-line 11002, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x y prefer-table hierarchy]))}, persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3831, :column 7, :end-line 3831, :end-column 18, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, :name cljs.core/persistent!, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3831, :ret-tag clj, :end-line 3831, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, set-print-fn! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 92, :column 7, :end-line 92, :end-column 20, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, :name cljs.core/set-print-fn!, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 92, :end-line 92, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, nnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1777, :column 7, :end-line 1777, :end-column 12, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, :name cljs.core/nnext, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1777, :ret-tag seq, :end-line 1777, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, Box {:num-fields 1, :protocols #{}, :name cljs.core/Box, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 7143, :record false, :end-line 7143, :tag function, :skip-protocol-flag nil}, balance-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8275, :column 8, :end-line 8275, :end-column 21, :private true, :arglists (quote ([key val left ins]))}, :private true, :name cljs.core/balance-right, :file "cljs/core.cljs", :end-column 21, :method-params ([key val left ins]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8275, :ret-tag clj, :end-line 8275, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left ins]))}, throw-no-method-error {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11045, :column 8, :end-line 11045, :end-column 29, :private true, :arglists (quote ([name dispatch-val]))}, :private true, :name cljs.core/throw-no-method-error, :file "cljs/core.cljs", :end-column 29, :method-params ([name dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11045, :ret-tag ignore, :end-line 11045, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name dispatch-val]))}, demunge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11523, :column 8, :end-line 11523, :end-column 19, :private true, :arglists (quote ([munged-name]))}, :private true, :name cljs.core/demunge-str, :file "cljs/core.cljs", :end-column 19, :method-params ([munged-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11523, :ret-tag string, :end-line 11523, :max-fixed-arity 1, :fn-var true, :arglists (quote ([munged-name]))}, add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10521, :column 7, :end-line 10521, :end-column 16, :arglists (quote ([iref key f])), :doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, :name cljs.core/add-watch, :file "cljs/core.cljs", :end-column 16, :method-params ([iref key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10521, :end-line 10521, :max-fixed-arity 3, :fn-var true, :arglists (quote ([iref key f])), :doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, not-every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4243, :column 7, :end-line 4243, :end-column 17, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, :name cljs.core/not-every?, :file "cljs/core.cljs", :end-column 17, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4243, :ret-tag boolean, :end-line 4243, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, rem {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2857, :column 7, :end-line 2857, :end-column 10, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, :name cljs.core/rem, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2857, :ret-tag number, :end-line 2857, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, ifind? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2151, :column 7, :end-line 2151, :end-column 13, :arglists (quote ([x])), :doc "Returns true if coll implements IFind"}, :name cljs.core/ifind?, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2151, :ret-tag boolean, :end-line 2151, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements IFind"}, pr-sb-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10214, :column 8, :end-line 10214, :end-column 23, :private true, :arglists (quote ([objs opts]))}, :private true, :name cljs.core/pr-sb-with-opts, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10214, :ret-tag goog.string/StringBuffer, :end-line 10214, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts]))}, ->HashMapIter {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 21, :column 10, :factory :positional, :line 7860, :end-line 7860, :arglists (quote ([nil-val root-iter seen])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/HashMapIter."}, :protocols #{cljs.core/Object}, :name cljs.core/->HashMapIter, :file "cljs/core.cljs", :end-column 21, :method-params ([nil-val root-iter seen]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7860, :ret-tag cljs.core/HashMapIter, :end-line 7860, :max-fixed-arity 3, :fn-var true, :arglists (quote ([nil-val root-iter seen])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/HashMapIter."}, ->t_cljs$core11293 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta11294])), :doc "Positional factory function for cljs.core/t_cljs$core11293.", :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t_cljs$core11293, :file "cljs/core.cljs", :method-params ([meta11294]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :variadic? false, :factory :positional, :line 4017, :ret-tag cljs.core/t_cljs$core11293, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta11294])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/t_cljs$core11293."}, BitmapIndexedNode {:num-fields 3, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/BitmapIndexedNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7244, :record false, :end-line 7244, :tag function, :skip-protocol-flag #{cljs.core/IIterable}}, ->NodeSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 17, :column 10, :factory :positional, :line 7709, :end-line 7709, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/NodeSeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->NodeSeq, :file "cljs/core.cljs", :end-column 17, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7709, :ret-tag cljs.core/NodeSeq, :end-line 7709, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/NodeSeq."}, some {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4248, :column 7, :end-line 4248, :end-column 11, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, :name cljs.core/some, :file "cljs/core.cljs", :end-column 11, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4248, :ret-tag #{any clj-nil}, :end-line 4248, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, INamed {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 20, :column 14, :line 852, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :end-line 852, :sigs {:-name {:name -name, :arglists ([x]), :doc "Returns the name String of x."}, :-namespace {:name -namespace, :arglists ([x]), :doc "Returns the namespace String of x."}}, :doc "Protocol for adding a name.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/INamed, :file "cljs/core.cljs", :end-column 20, :column 1, :line 852, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :info nil, :end-line 852, :tag any, :sigs {:-name {:name -name, :arglists ([x]), :doc "Returns the name String of x."}, :-namespace {:name -namespace, :arglists ([x]), :doc "Returns the namespace String of x."}}, :impls #{cljs.core/MultiFn cljs.core/Keyword cljs.core/Symbol}, :doc "Protocol for adding a name.", :jsdoc ("@interface")}, ->Box {:protocol-inline nil, :meta {:protocols #{}, :file "cljs/core.cljs", :end-column 13, :column 10, :factory :positional, :line 7143, :end-line 7143, :arglists (quote ([val])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/Box."}, :protocols #{}, :name cljs.core/->Box, :file "cljs/core.cljs", :end-column 13, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7143, :ret-tag cljs.core/Box, :end-line 7143, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/Box."}, IReduce {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 21, :column 14, :line 702, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :end-line 702, :sigs {:-reduce {:name -reduce, :arglists ([coll f] [coll f start]), :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."}}, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IReduce, :file "cljs/core.cljs", :end-column 21, :column 1, :line 702, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :info nil, :end-line 702, :tag any, :sigs {:-reduce {:name -reduce, :arglists ([coll f] [coll f start]), :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."}}, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/Cycle cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/Iterate cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ArrayChunk cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :jsdoc ("@interface")}, neg-int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2307, :column 16, :end-line 2307, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is negative."}, :name cljs.core/neg-int?, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2307, :ret-tag boolean, :end-line 2307, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is negative."}, drop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4784, :column 7, :end-line 4784, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[n] [n coll]], :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[n] [n coll]], :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params [[n] [n coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 4784, :end-line 4784, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided."}, NodeIterator {:num-fields 4, :protocols #{cljs.core/Object}, :name cljs.core/NodeIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 11, :line 7206, :record false, :end-line 7206, :tag function, :skip-protocol-flag nil}, js-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2190, :column 7, :end-line 2190, :end-column 13, :arglists (quote ([] [& keyvals])), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [[]], :arglists ([] [& keyvals]), :arglists-meta (nil nil)}}, :name cljs.core/js-obj, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [[]], :arglists ([] [& keyvals]), :arglists-meta (nil nil)}, :method-params [[]], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag object} {:fixed-arity 0, :variadic? true, :tag any}], :line 2190, :end-line 2190, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keyvals]), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values."}, ITransientCollection {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 34, :column 14, :line 799, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :end-line 799, :sigs {:-conj! {:name -conj!, :arglists ([tcoll val]), :doc "Adds value val to tcoll and returns tcoll."}, :-persistent! {:name -persistent!, :arglists ([tcoll]), :doc "Creates a persistent data structure from tcoll and returns it."}}, :doc "Protocol for adding basic functionality to transient collections.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ITransientCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 799, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :info nil, :end-line 799, :tag any, :sigs {:-conj! {:name -conj!, :arglists ([tcoll val]), :doc "Adds value val to tcoll and returns tcoll."}, :-persistent! {:name -persistent!, :arglists ([tcoll]), :doc "Creates a persistent data structure from tcoll and returns it."}}, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/TransientHashSet}, :doc "Protocol for adding basic functionality to transient collections.", :jsdoc ("@interface")}, Atom {:num-fields 4, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Atom, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 4431, :record false, :end-line 4431, :tag function, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1869, :column 7, :end-line 1869, :end-column 10, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll n] [coll n not-found]], :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :name cljs.core/nth, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll n] [coll n not-found]], :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params [[coll n] [coll n not-found]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag #{any clj-nil}} {:fixed-arity 3, :variadic? false, :tag #{nil any clj-nil}}], :line 1869, :end-line 1869, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences."}, sorted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2159, :column 7, :end-line 2159, :end-column 14, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, :name cljs.core/sorted?, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2159, :ret-tag boolean, :end-line 2159, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 235, :column 16, :end-line 235, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, :name cljs.core/nil?, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 235, :ret-tag boolean, :end-line 235, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, split-at {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4915, :column 7, :end-line 4915, :end-column 15, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, :name cljs.core/split-at, :file "cljs/core.cljs", :end-column 15, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4915, :ret-tag cljs.core/IVector, :end-line 4915, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, TransientHashSet {:meta {:file "cljs/core.cljs", :line 9149, :column 10, :end-line 9149, :end-column 26, :declared true}, :num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/TransientHashSet, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 9285, :record false, :declared true, :end-line 9285, :tag function, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, *e {:name cljs.core/*e, :file "cljs/core.cljs", :line 217, :column 1, :end-line 219, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl", :meta {:file "cljs/core.cljs", :line 219, :column 3, :end-line 219, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl"}}, array-map-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6644, :column 8, :end-line 6644, :end-column 27, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/array-map-extend-kv, :file "cljs/core.cljs", :end-column 27, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6644, :ret-tag array, :end-line 6644, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, prn-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10229, :column 7, :end-line 10229, :end-column 24, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, :name cljs.core/prn-str-with-opts, :file "cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10229, :ret-tag string, :end-line 10229, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, not-native {:name cljs.core/not-native, :file "cljs/core.cljs", :line 226, :column 1, :end-line 226, :end-column 16, :meta {:file "cljs/core.cljs", :line 226, :column 6, :end-line 226, :end-column 16}, :tag clj-nil}, random-sample {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10664, :column 7, :end-line 10664, :end-column 20, :arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[prob] [prob coll]], :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}}, :name cljs.core/random-sample, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[prob] [prob coll]], :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}, :method-params [[prob] [prob coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 10664, :end-line 10664, :max-fixed-arity 2, :fn-var true, :arglists ([prob] [prob coll]), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided."}, select-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9133, :column 7, :end-line 9133, :end-column 18, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, :name cljs.core/select-keys, :file "cljs/core.cljs", :end-column 18, :method-params ([map keyseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9133, :ret-tag clj, :end-line 9133, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, bit-and {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2869, :column 7, :end-line 2869, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x y]], :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x y]], :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params [[x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2869, :end-line 2869, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and"}, bounded-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3767, :column 7, :end-line 3767, :end-column 20, :arglists (quote ([n coll])), :doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :added "1.9"}, :added "1.9", :name cljs.core/bounded-count, :file "cljs/core.cljs", :end-column 20, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3767, :ret-tag number, :end-line 3767, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq"}, update {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5342, :column 7, :end-line 5342, :end-column 13, :arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :top-fn {:variadic? true, :fixed-arity 6, :max-fixed-arity 6, :method-params [[m k f] [m k f x] [m k f x y] [m k f x y z]], :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? true, :fixed-arity 6, :max-fixed-arity 6, :method-params [[m k f] [m k f x] [m k f x y] [m k f x y z]], :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}, :method-params [[m k f] [m k f x] [m k f x y] [m k f x y z]], :protocol-impl nil, :fixed-arity 6, :arglists-meta (nil nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 3, :variadic? false, :tag #{clj any}} {:fixed-arity 4, :variadic? false, :tag #{clj any}} {:fixed-arity 5, :variadic? false, :tag #{clj any}} {:fixed-arity 6, :variadic? false, :tag #{clj any}} {:fixed-arity 6, :variadic? true, :tag #{clj any}}], :line 5342, :end-line 5342, :max-fixed-arity 6, :fn-var true, :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value."}, gensym_counter {:name cljs.core/gensym_counter, :file "cljs/core.cljs", :line 10552, :column 1, :end-line 10554, :end-column 17, :jsdoc ["@type {*}"], :meta {:file "cljs/core.cljs", :line 10554, :column 3, :end-line 10554, :end-column 17, :jsdoc ["@type {*}"]}, :tag clj-nil}, find-macros-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11679, :column 7, :end-line 11679, :end-column 21, :arglists (quote ([ns])), :doc "Returns the macros namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only."}, :name cljs.core/find-macros-ns, :file "cljs/core.cljs", :end-column 21, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11679, :ret-tag #{cljs.core/Namespace any clj-nil}, :end-line 11679, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns])), :doc "Returns the macros namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only."}, list* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3813, :column 7, :end-line 3813, :end-column 12, :arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[args] [a args] [a b args] [a b c args]], :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/list*, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[args] [a args] [a b args] [a b c args]], :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}, :method-params [[args] [a args] [a b args] [a b c args]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag seq} {:fixed-arity 2, :variadic? false, :tag clj} {:fixed-arity 3, :variadic? false, :tag clj} {:fixed-arity 4, :variadic? false, :tag clj} {:fixed-arity 4, :variadic? true, :tag clj}], :line 3813, :end-line 3813, :max-fixed-arity 4, :fn-var true, :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence."}, array-index-of-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6580, :column 8, :end-line 6580, :end-column 31, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-keyword?, :file "cljs/core.cljs", :end-column 31, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6580, :ret-tag number, :end-line 6580, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->Keyword {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :file "cljs/core.cljs", :end-column 17, :column 10, :factory :positional, :line 3318, :end-line 3318, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :doc "Positional factory function for cljs.core/Keyword."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/->Keyword, :file "cljs/core.cljs", :end-column 17, :method-params ([ns name fqn _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 3318, :ret-tag cljs.core/Keyword, :end-line 3318, :max-fixed-arity 4, :fn-var true, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :doc "Positional factory function for cljs.core/Keyword."}, update-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5315, :column 7, :end-line 5315, :end-column 16, :arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :top-fn {:variadic? true, :fixed-arity 6, :max-fixed-arity 6, :method-params [[m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]], :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update-in, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? true, :fixed-arity 6, :max-fixed-arity 6, :method-params [[m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]], :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}, :method-params [[m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]], :protocol-impl nil, :fixed-arity 6, :arglists-meta (nil nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 3, :variadic? false, :tag #{clj any}} {:fixed-arity 4, :variadic? false, :tag #{clj any}} {:fixed-arity 5, :variadic? false, :tag #{clj any}} {:fixed-arity 6, :variadic? false, :tag #{clj any}} {:fixed-arity 6, :variadic? true, :tag #{clj any}}], :line 5315, :end-line 5315, :max-fixed-arity 6, :fn-var true, :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created."}, prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11243, :column 7, :end-line 11243, :end-column 20, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, :name cljs.core/prefer-method, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val-x dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11243, :ret-tag any, :end-line 11243, :max-fixed-arity 3, :fn-var true, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, hash-symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1054, :column 8, :end-line 1054, :end-column 19, :private true, :arglists (quote ([sym]))}, :private true, :name cljs.core/hash-symbol, :file "cljs/core.cljs", :end-column 19, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1054, :ret-tag number, :end-line 1054, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, ensure-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1457, :column 7, :end-line 1457, :end-column 21, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, :name cljs.core/ensure-reduced, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1457, :ret-tag cljs.core/Reduced, :end-line 1457, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, edit-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7177, :column 8, :end-line 7177, :end-column 20, :private true, :arglists (quote ([inode edit i a] [inode edit i a j b])), :top-fn {:variadic? false, :fixed-arity 6, :max-fixed-arity 6, :method-params [[inode edit i a] [inode edit i a j b]], :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/edit-and-set, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? false, :fixed-arity 6, :max-fixed-arity 6, :method-params [[inode edit i a] [inode edit i a j b]], :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}, :method-params [[inode edit i a] [inode edit i a j b]], :protocol-impl nil, :fixed-arity 6, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 4, :variadic? false, :tag any} {:fixed-arity 6, :variadic? false, :tag any}], :line 7177, :end-line 7177, :max-fixed-arity 6, :fn-var true, :arglists ([inode edit i a] [inode edit i a j b])}, ->PersistentArrayMap {:protocol-inline nil, :meta {:protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 28, :column 10, :factory :positional, :line 6829, :end-line 6829, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/PersistentArrayMap."}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentArrayMap, :file "cljs/core.cljs", :end-column 28, :method-params ([meta cnt arr __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6829, :ret-tag cljs.core/PersistentArrayMap, :end-line 6829, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/PersistentArrayMap."}, instance? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1043, :column 16, :end-line 1043, :end-column 25, :tag boolean, :arglists (quote ([c x])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, :name cljs.core/instance?, :file "cljs/core.cljs", :end-column 25, :method-params ([c x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1043, :ret-tag boolean, :end-line 1043, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([c x])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, mix-collection-hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1339, :column 15, :end-line 1339, :end-column 34, :tag number, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/mix-collection-hash, :file "cljs/core.cljs", :end-column 34, :method-params ([hash-basis count]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1339, :ret-tag number, :end-line 1339, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, re-find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10000, :column 7, :end-line 10000, :end-column 14, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, :name cljs.core/re-find, :file "cljs/core.cljs", :end-column 14, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10000, :ret-tag #{clj cljs.core/IVector any cljs.core/MetaFn clj-nil}, :end-line 10000, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, run! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10711, :column 7, :end-line 10711, :end-column 11, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, :name cljs.core/run!, :file "cljs/core.cljs", :end-column 11, :method-params ([proc coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10711, :ret-tag clj-nil, :end-line 10711, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, char-escapes {:name cljs.core/char-escapes, :file "cljs/core.cljs", :line 10083, :column 1, :end-line 10083, :end-column 28, :private true, :meta {:file "cljs/core.cljs", :line 10083, :column 16, :end-line 10083, :end-column 28, :private true}, :tag object}, ES6Iterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6Iterator, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 1305, :record false, :end-line 1305, :tag function, :skip-protocol-flag nil}, val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9104, :column 7, :end-line 9104, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, :name cljs.core/val, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9104, :ret-tag any, :end-line 9104, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, unchecked-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2731, :column 15, :end-line 2731, :end-column 28, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params [[] [x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag number} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2731, :ret-tag number, :end-line 2731, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, transformer-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4192, :column 7, :end-line 4192, :end-column 27, :arglists (quote ([xform sourceIter multi]))}, :name cljs.core/transformer-iterator, :file "cljs/core.cljs", :end-column 27, :method-params ([xform sourceIter multi]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4192, :ret-tag cljs.core/TransformerIterator, :end-line 4192, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform sourceIter multi]))}, not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 252, :column 7, :end-line 252, :end-column 10, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, :name cljs.core/not, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 252, :ret-tag boolean, :end-line 252, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, -vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 874, :column 4, :end-line 874, :end-column 12, :protocol cljs.core/IVolatile, :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IVolatile, :name cljs.core/-vreset!, :file "cljs/core.cljs", :end-column 12, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 872, :ret-tag any, :end-line 874, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."}, fn->comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2433, :column 17, :end-line 2433, :end-column 31, :private true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, :private true, :name cljs.core/fn->comparator, :file "cljs/core.cljs", :end-column 31, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2433, :ret-tag #{number function}, :end-line 2433, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2082, :column 7, :end-line 2082, :end-column 16, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, :name cljs.core/with-meta, :file "cljs/core.cljs", :end-column 16, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2082, :ret-tag #{clj cljs.core/MetaFn clj-nil}, :end-line 2082, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, unreduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1462, :column 7, :end-line 1462, :end-column 16, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, :name cljs.core/unreduced, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1462, :ret-tag #{nil any}, :end-line 1462, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, record? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2174, :column 7, :end-line 2174, :end-column 14, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, :name cljs.core/record?, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2174, :ret-tag boolean, :end-line 2174, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, type {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 311, :column 7, :end-line 311, :end-column 11, :arglists (quote ([x])), :doc "Return x's constructor."}, :name cljs.core/type, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 311, :ret-tag #{any clj-nil}, :end-line 311, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return x's constructor."}, identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 230, :column 16, :end-line 230, :end-column 26, :tag boolean, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, :name cljs.core/identical?, :file "cljs/core.cljs", :end-column 26, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 230, :ret-tag boolean, :end-line 230, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, -namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 856, :column 30, :end-line 856, :end-column 40, :tag #{string clj-nil}, :protocol cljs.core/INamed, :doc "Returns the namespace String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-namespace, :file "cljs/core.cljs", :end-column 40, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 852, :ret-tag #{string clj-nil}, :end-line 856, :max-fixed-arity 1, :tag #{string clj-nil}, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of x."}, unchecked-divide-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2755, :column 15, :end-line 2755, :end-column 35, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-divide-int, :file "cljs/core.cljs", :end-column 35, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag number} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2755, :ret-tag number, :end-line 2755, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, ns-name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11698, :column 7, :end-line 11698, :end-column 14, :arglists (quote ([ns-obj])), :doc "Returns the name of the namespace, a Namespace object.\n  Bootstrap only."}, :name cljs.core/ns-name, :file "cljs/core.cljs", :end-column 14, :method-params ([ns-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11698, :ret-tag any, :end-line 11698, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns-obj])), :doc "Returns the name of the namespace, a Namespace object.\n  Bootstrap only."}, swap-global-hierarchy! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10876, :column 8, :end-line 10876, :end-column 30, :private true, :arglists (quote ([f & args])), :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :private true, :name cljs.core/swap-global-hierarchy!, :file "cljs/core.cljs", :end-column 30, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? true, :tag any}], :line 10876, :ret-tag any, :end-line 10876, :max-fixed-arity 1, :fn-var true, :arglists ([f & args])}, max-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9538, :column 7, :end-line 9538, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[k x] [k x y]], :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max-key, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[k x] [k x y]], :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params [[k x] [k x y]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false} {:fixed-arity 3, :variadic? false} {:fixed-arity 3, :variadic? true, :tag #{nil any}}], :line 9538, :end-line 9538, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned."}, ->PersistentTreeSet {:protocol-inline nil, :meta {:protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 27, :column 10, :factory :positional, :line 9322, :end-line 9322, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :doc "Positional factory function for cljs.core/PersistentTreeSet."}, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentTreeSet, :file "cljs/core.cljs", :end-column 27, :method-params ([meta tree-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 9322, :ret-tag cljs.core/PersistentTreeSet, :end-line 9322, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :doc "Positional factory function for cljs.core/PersistentTreeSet."}, *out* {:meta {:file "cljs/core.cljs", :line 65, :column 3, :end-line 65, :end-column 8, :dynamic true, :jsdoc ["@type {*}"]}, :name cljs.core/*out*, :file "cljs/core.cljs", :end-column 8, :column 1, :dynamic true, :line 62, :end-line 65, :tag any, :jsdoc ["@type {*}"]}, ->ChunkBuffer {:protocol-inline nil, :meta {:protocols #{cljs.core/Object cljs.core/ICounted}, :file "cljs/core.cljs", :end-column 21, :column 10, :factory :positional, :line 3512, :end-line 3512, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}, :doc "Positional factory function for cljs.core/ChunkBuffer."}, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/->ChunkBuffer, :file "cljs/core.cljs", :end-column 21, :method-params ([buf end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 3512, :ret-tag cljs.core/ChunkBuffer, :end-line 3512, :max-fixed-arity 2, :fn-var true, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}, :doc "Positional factory function for cljs.core/ChunkBuffer."}, hash-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 989, :column 7, :end-line 989, :end-column 18, :arglists (quote ([k]))}, :name cljs.core/hash-string, :file "cljs/core.cljs", :end-column 18, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 989, :ret-tag number, :end-line 989, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ValSeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ValSeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 9030, :record false, :end-line 9030, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11041, :column 4, :end-line 11041, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11034, :ret-tag any, :end-line 11041, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, set-validator! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4556, :column 7, :end-line 4556, :end-column 21, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, :name cljs.core/set-validator!, :file "cljs/core.cljs", :end-column 21, :method-params ([iref val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4556, :end-line 4556, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, ident? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3376, :column 7, :end-line 3376, :end-column 13, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword"}, :name cljs.core/ident?, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3376, :ret-tag boolean, :end-line 3376, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword"}, -meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 694, :column 16, :end-line 694, :end-column 21, :tag clj-or-nil, :protocol cljs.core/IMeta, :doc "Returns the metadata of object o.", :arglists (quote ([o]))}, :protocol cljs.core/IMeta, :name cljs.core/-meta, :file "cljs/core.cljs", :end-column 21, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 692, :ret-tag clj-or-nil, :end-line 694, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of object o."}, RedNode {:meta {:file "cljs/core.cljs", :line 8248, :column 10, :end-line 8248, :end-column 17, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/RedNode, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 8473, :record false, :declared true, :end-line 8473, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, -dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11043, :column 4, :end-line 11043, :end-column 16, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-dispatch-fn, :file "cljs/core.cljs", :end-column 16, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11034, :ret-tag any, :end-line 11043, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, ->IndexedSeqIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 28, :column 10, :factory :positional, :line 1576, :end-line 1576, :arglists (quote ([arr i])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/IndexedSeqIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->IndexedSeqIterator, :file "cljs/core.cljs", :end-column 28, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 1576, :ret-tag cljs.core/IndexedSeqIterator, :end-line 1576, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/IndexedSeqIterator."}, -add-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11036, :column 4, :end-line 11036, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val method]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val method]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11034, :ret-tag any, :end-line 11036, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val method])), :doc nil}, balance-left-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8297, :column 8, :end-line 8297, :end-column 24, :private true, :arglists (quote ([key val del right]))}, :private true, :name cljs.core/balance-left-del, :file "cljs/core.cljs", :end-column 24, :method-params ([key val del right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8297, :ret-tag clj, :end-line 8297, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val del right]))}, swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4510, :column 7, :end-line 4510, :end-column 12, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[a f] [a f x] [a f x y]], :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/swap!, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[a f] [a f x] [a f x y]], :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}, :method-params [[a f] [a f x] [a f x y]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag #{nil any}} {:fixed-arity 3, :variadic? false, :tag #{nil any}} {:fixed-arity 4, :variadic? false, :tag #{nil any}} {:fixed-arity 4, :variadic? true, :tag #{nil any}}], :line 4510, :end-line 4510, :max-fixed-arity 4, :fn-var true, :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in."}, vals {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9098, :column 7, :end-line 9098, :end-column 11, :arglists (quote ([map])), :doc "Returns a sequence of the map's values, in the same order as (seq map)."}, :name cljs.core/vals, :file "cljs/core.cljs", :end-column 11, :method-params ([map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9098, :ret-tag #{cljs.core/ValSeq clj-nil}, :end-line 9098, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map])), :doc "Returns a sequence of the map's values, in the same order as (seq map)."}, Repeat {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Repeat, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 4920, :record false, :end-line 4920, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -chunked-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 849, :column 4, :end-line 849, :end-column 17, :protocol cljs.core/IChunkedNext, :doc "Returns a new collection of coll without the first chunk.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 847, :ret-tag any, :end-line 849, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first chunk."}, Single {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/Single, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 4094, :record false, :end-line 4094, :tag function, :skip-protocol-flag nil}, unchecked-subtract {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2793, :column 15, :end-line 2793, :end-column 33, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag number} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2793, :ret-tag number, :end-line 2793, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, tap> {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11569, :column 16, :end-line 11569, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value."}, :name cljs.core/tap>, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11569, :ret-tag boolean, :end-line 11569, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value."}, remove-pair {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7165, :column 8, :end-line 7165, :end-column 19, :private true, :arglists (quote ([arr i]))}, :private true, :name cljs.core/remove-pair, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 7165, :ret-tag array, :end-line 7165, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i]))}, IMap {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 18, :column 14, :line 651, :protocol-info {:methods {-dissoc [[coll k]]}}, :end-line 651, :sigs {:-dissoc {:name -dissoc, :arglists ([coll k]), :doc "Returns a new collection of coll without the mapping for key k."}}, :doc "Protocol for adding mapping functionality to collections.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IMap, :file "cljs/core.cljs", :end-column 18, :column 1, :line 651, :protocol-info {:methods {-dissoc [[coll k]]}}, :info nil, :end-line 651, :tag any, :sigs {:-dissoc {:name -dissoc, :arglists ([coll k]), :doc "Returns a new collection of coll without the mapping for key k."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentTreeMap}, :doc "Protocol for adding mapping functionality to collections.", :jsdoc ("@interface")}, ->SeqIter {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 17, :column 10, :factory :positional, :line 4050, :end-line 4050, :arglists (quote ([_seq _next])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/SeqIter."}, :protocols #{cljs.core/Object}, :name cljs.core/->SeqIter, :file "cljs/core.cljs", :end-column 17, :method-params ([_seq _next]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4050, :ret-tag cljs.core/SeqIter, :end-line 4050, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_seq _next])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/SeqIter."}, sorted-set-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9459, :column 7, :end-line 9459, :end-column 20, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set-by, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}, :method-params [(comparator keys)], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? true, :tag #{nil any}}], :line 9459, :ret-tag any, :end-line 9459, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keys]), :doc "Returns a new sorted set with supplied keys, using the supplied comparator."}, PersistentVector {:num-fields 6, :protocols #{cljs.core/APersistentVector cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentVector, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 5498, :record false, :end-line 5498, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, cloneable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1219, :column 7, :end-line 1219, :end-column 17, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, :name cljs.core/cloneable?, :file "cljs/core.cljs", :end-column 17, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1219, :ret-tag boolean, :end-line 1219, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, qualified-ident? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3384, :column 7, :end-line 3384, :end-column 23, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword with a namespace"}, :name cljs.core/qualified-ident?, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3384, :ret-tag boolean, :end-line 3384, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword with a namespace"}, hash-string* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 972, :column 7, :end-line 972, :end-column 19, :arglists (quote ([s]))}, :name cljs.core/hash-string*, :file "cljs/core.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 972, :ret-tag number, :end-line 972, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, key-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7147, :column 7, :end-line 7147, :end-column 15, :arglists (quote ([key other]))}, :name cljs.core/key-test, :file "cljs/core.cljs", :end-column 15, :method-params ([key other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 7147, :ret-tag boolean, :end-line 7147, :max-fixed-arity 2, :fn-var true, :arglists (quote ([key other]))}, -reset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11035, :column 4, :end-line 11035, :end-column 10, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :file "cljs/core.cljs", :end-column 10, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11034, :ret-tag any, :end-line 11035, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, true? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2233, :column 16, :end-line 2233, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, :name cljs.core/true?, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2233, :ret-tag boolean, :end-line 2233, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, find-ns-obj* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11613, :column 8, :end-line 11613, :end-column 20, :private true, :arglists (quote ([ctxt xs])), :doc "Bootstrap only."}, :private true, :name cljs.core/find-ns-obj*, :file "cljs/core.cljs", :end-column 20, :method-params ([ctxt xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11613, :ret-tag #{nil clj-nil}, :end-line 11613, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ctxt xs])), :doc "Bootstrap only."}, array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 441, :column 14, :end-line 441, :end-column 19, :tag array, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, :name cljs.core/array, :file "cljs/core.cljs", :end-column 19, :method-params ([var-args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 441, :ret-tag array, :end-line 441, :max-fixed-arity 1, :tag array, :fn-var true, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10273, :column 3, :end-line 10273, :end-column 8, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, :name cljs.core/print, :file "cljs/core.cljs", :end-column 8, :method-params ([objs]), :protocol-impl nil, :arglists-meta (), :column 1, :variadic? true, :line 10270, :ret-tag clj-nil, :end-line 10273, :max-fixed-arity 0, :fn-var true, :arglists nil, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, -peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 673, :column 4, :end-line 673, :end-column 9, :protocol cljs.core/IStack, :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-peek, :file "cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 669, :ret-tag any, :end-line 673, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the item from the top of the stack. Is used by cljs.core/peek."}, ISeq {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 18, :column 14, :line 614, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :end-line 614, :sigs {:-first {:name -first, :arglists ([coll]), :doc "Returns the first item in the collection coll. Used by cljs.core/first."}, :-rest {:name -rest, :arglists ([coll]), :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()"}}, :doc "Protocol for collections to provide access to their items as sequences.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ISeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 614, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :info nil, :end-line 614, :tag any, :sigs {:-first {:name -first, :arglists ([coll]), :doc "Returns the first item in the collection coll. Used by cljs.core/first."}, :-rest {:name -rest, :arglists ([coll]), :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()"}}, :impls #{cljs.core/RangeChunk cljs.core/Cons cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/Cycle cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/Iterate cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq}, :doc "Protocol for collections to provide access to their items as sequences.", :jsdoc ("@interface")}, empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1809, :column 7, :end-line 1809, :end-column 12, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, :name cljs.core/empty, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1809, :ret-tag #{any clj-nil}, :end-line 1809, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11238, :column 7, :end-line 11238, :end-column 20, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, :name cljs.core/remove-method, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11238, :ret-tag any, :end-line 11238, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, PersistentQueueSeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueueSeq, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6206, :record false, :end-line 6206, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, balance-right-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8316, :column 8, :end-line 8316, :end-column 25, :private true, :arglists (quote ([key val left del]))}, :private true, :name cljs.core/balance-right-del, :file "cljs/core.cljs", :end-column 25, :method-params ([key val left del]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8316, :ret-tag clj, :end-line 8316, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left del]))}, volatile! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4582, :column 7, :end-line 4582, :end-column 16, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, :name cljs.core/volatile!, :file "cljs/core.cljs", :end-column 16, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4582, :ret-tag cljs.core/Volatile, :end-line 4582, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, / {:protocol-inline nil, :meta {:tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :file "cljs/core.cljs"}, :name cljs.core//, :file "cljs/core.cljs", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag number} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2638, :ret-tag number, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, bitpos {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7174, :column 8, :end-line 7174, :end-column 14, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/bitpos, :file "cljs/core.cljs", :end-column 14, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 7174, :ret-tag number, :end-line 7174, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, Many {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/Many, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 4080, :record false, :end-line 4080, :tag function, :skip-protocol-flag nil}, bit-or {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2875, :column 7, :end-line 2875, :end-column 13, :arglists (quote ([x y] [x y & more])), :doc "Bitwise or", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x y]], :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-or, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x y]], :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params [[x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2875, :end-line 2875, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise or"}, m3-fmix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 933, :column 15, :end-line 933, :end-column 22, :tag number, :arglists (quote ([h1 len]))}, :name cljs.core/m3-fmix, :file "cljs/core.cljs", :end-column 22, :method-params ([h1 len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 933, :ret-tag number, :end-line 933, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 len]))}, vector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5737, :column 7, :end-line 5737, :end-column 13, :arglists (quote ([& args])), :doc "Creates a new vector containing the args.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name cljs.core/vector, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag #{clj cljs.core/IVector any cljs.core/MetaFn clj-nil}}], :line 5737, :ret-tag any, :end-line 5737, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "Creates a new vector containing the args."}, hash-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3009, :column 8, :end-line 3009, :end-column 17, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/hash-coll, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3009, :ret-tag #{nil number}, :end-line 3009, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, clone-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7156, :column 8, :end-line 7156, :end-column 21, :private true, :arglists (quote ([arr i a] [arr i a j b])), :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[arr i a] [arr i a j b]], :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/clone-and-set, :file "cljs/core.cljs", :end-column 21, :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[arr i a] [arr i a j b]], :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}, :method-params [[arr i a] [arr i a j b]], :protocol-impl nil, :fixed-arity 5, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 3, :variadic? false, :tag array} {:fixed-arity 5, :variadic? false, :tag array}], :line 7156, :end-line 7156, :max-fixed-arity 5, :fn-var true, :arglists ([arr i a] [arr i a j b])}, array->transient-hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7134, :column 8, :end-line 7134, :end-column 33, :private true, :arglists (quote ([len arr]))}, :private true, :name cljs.core/array->transient-hash-map, :file "cljs/core.cljs", :end-column 33, :method-params ([len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 7134, :ret-tag clj, :end-line 7134, :max-fixed-arity 2, :fn-var true, :arglists (quote ([len arr]))}, >= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2681, :column 16, :end-line 2681, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>=, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? true, :tag boolean}], :line 2681, :ret-tag boolean, :end-line 2681, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false."}, ->TransientHashSet {:protocol-inline nil, :meta {:protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 26, :column 10, :factory :positional, :line 9285, :end-line 9285, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TransientHashSet."}, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/->TransientHashSet, :file "cljs/core.cljs", :end-column 26, :method-params ([transient-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 9285, :ret-tag cljs.core/TransientHashSet, :end-line 9285, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TransientHashSet."}, drop-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4809, :column 7, :end-line 4809, :end-column 16, :arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[s] [n s]], :arglists ([s] [n s]), :arglists-meta (nil nil)}}, :name cljs.core/drop-last, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[s] [n s]], :arglists ([s] [n s]), :arglists-meta (nil nil)}, :method-params [[s] [n s]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 4809, :end-line 4809, :max-fixed-arity 2, :fn-var true, :arglists ([s] [n s]), :doc "Return a lazy sequence of all but the last n (default 1) items in coll"}, ->ArrayIter {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 19, :column 10, :factory :positional, :line 4035, :end-line 4035, :arglists (quote ([arr i])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ArrayIter."}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayIter, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4035, :ret-tag cljs.core/ArrayIter, :end-line 4035, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/ArrayIter."}, object? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 264, :column 7, :end-line 264, :end-column 14, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, :name cljs.core/object?, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 264, :ret-tag boolean, :end-line 264, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, ->ArrayNodeSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 22, :column 10, :factory :positional, :line 7790, :end-line 7790, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/ArrayNodeSeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ArrayNodeSeq, :file "cljs/core.cljs", :end-column 22, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7790, :ret-tag cljs.core/ArrayNodeSeq, :end-line 7790, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/ArrayNodeSeq."}, lift-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10307, :column 8, :end-line 10307, :end-column 15, :private true, :arglists (quote ([m])), :doc "Returns [lifted-ns lifted-map] or nil if m can't be lifted."}, :private true, :name cljs.core/lift-ns, :file "cljs/core.cljs", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10307, :ret-tag #{cljs.core/IVector clj-nil}, :end-line 10307, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns [lifted-ns lifted-map] or nil if m can't be lifted."}, tree-map-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8656, :column 8, :end-line 8656, :end-column 23, :private true, :arglists (quote ([left right]))}, :private true, :name cljs.core/tree-map-append, :file "cljs/core.cljs", :end-column 23, :method-params ([left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8656, :ret-tag #{nil clj}, :end-line 8656, :max-fixed-arity 2, :fn-var true, :arglists (quote ([left right]))}, not-empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4012, :column 7, :end-line 4012, :end-column 16, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, :name cljs.core/not-empty, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4012, :ret-tag #{nil clj-nil}, :end-line 4012, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, distinct {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9483, :column 7, :end-line 9483, :end-column 15, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [coll]], :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/distinct, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [coll]], :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params [[] [coll]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 0, :variadic? false, :tag function} {:fixed-arity 1, :variadic? false, :tag cljs.core/LazySeq}], :line 9483, :end-line 9483, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided."}, partition {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5265, :column 7, :end-line 5265, :end-column 16, :arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[n coll] [n step coll] [n step pad coll]], :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 4, :max-fixed-arity 4, :method-params [[n coll] [n step coll] [n step pad coll]], :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}, :method-params [[n coll] [n step coll] [n step pad coll]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag cljs.core/LazySeq} {:fixed-arity 4, :variadic? false, :tag cljs.core/LazySeq}], :line 5265, :end-line 5265, :max-fixed-arity 4, :fn-var true, :arglists ([n coll] [n step coll] [n step pad coll]), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items."}, IMultiFn {:meta {:file "cljs/core.cljs", :line 11034, :column 14, :end-line 11034, :end-column 22, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}, :sigs {:-remove-method {:name -remove-method, :arglists ([mf dispatch-val]), :doc nil}, :-methods {:name -methods, :arglists ([mf]), :doc nil}, :-dispatch-fn {:name -dispatch-fn, :arglists ([mf]), :doc nil}, :-add-method {:name -add-method, :arglists ([mf dispatch-val method]), :doc nil}, :-prefers {:name -prefers, :arglists ([mf]), :doc nil}, :-reset {:name -reset, :arglists ([mf]), :doc nil}, :-get-method {:name -get-method, :arglists ([mf dispatch-val]), :doc nil}, :-prefer-method {:name -prefer-method, :arglists ([mf dispatch-val dispatch-val-y]), :doc nil}, :-default-dispatch-val {:name -default-dispatch-val, :arglists ([mf]), :doc nil}}}, :protocol-symbol true, :name cljs.core/IMultiFn, :file "cljs/core.cljs", :end-column 22, :column 1, :line 11034, :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}, :info nil, :end-line 11034, :tag any, :sigs {:-remove-method {:name -remove-method, :arglists ([mf dispatch-val]), :doc nil}, :-methods {:name -methods, :arglists ([mf]), :doc nil}, :-dispatch-fn {:name -dispatch-fn, :arglists ([mf]), :doc nil}, :-add-method {:name -add-method, :arglists ([mf dispatch-val method]), :doc nil}, :-prefers {:name -prefers, :arglists ([mf]), :doc nil}, :-reset {:name -reset, :arglists ([mf]), :doc nil}, :-get-method {:name -get-method, :arglists ([mf dispatch-val]), :doc nil}, :-prefer-method {:name -prefer-method, :arglists ([mf dispatch-val dispatch-val-y]), :doc nil}, :-default-dispatch-val {:name -default-dispatch-val, :arglists ([mf]), :doc nil}}, :impls #{cljs.core/MultiFn}, :jsdoc ("@interface")}, ->Many {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 14, :column 10, :factory :positional, :line 4080, :end-line 4080, :arglists (quote ([vals])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/Many."}, :protocols #{cljs.core/Object}, :name cljs.core/->Many, :file "cljs/core.cljs", :end-column 14, :method-params ([vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4080, :ret-tag cljs.core/Many, :end-line 4080, :max-fixed-arity 1, :fn-var true, :arglists (quote ([vals])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/Many."}, DEMUNGE_PATTERN {:name cljs.core/DEMUNGE_PATTERN, :file "cljs/core.cljs", :line 395, :column 1, :end-line 395, :end-column 21, :meta {:file "cljs/core.cljs", :line 395, :column 6, :end-line 395, :end-column 21}, :tag clj-nil}, fix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2807, :column 16, :end-line 2807, :end-column 19, :tag number, :private true, :arglists (quote ([q]))}, :private true, :name cljs.core/fix, :file "cljs/core.cljs", :end-column 19, :method-params ([q]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2807, :ret-tag number, :end-line 2807, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([q]))}, EmptyList {:num-fields 1, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/EmptyList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3129, :record false, :end-line 3129, :tag function, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, HashMapIter {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/HashMapIter, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 7860, :record false, :end-line 7860, :tag function, :skip-protocol-flag nil}, IAssociative {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 26, :column 14, :line 638, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :end-line 638, :sigs {:-contains-key? {:name -contains-key?, :arglists ([coll k]), :doc "Returns true if k is a key in coll."}, :-assoc {:name -assoc, :arglists ([coll k v]), :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it."}}, :doc "Protocol for adding associativity to collections.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IAssociative, :file "cljs/core.cljs", :end-column 26, :column 1, :line 638, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :info nil, :end-line 638, :tag any, :sigs {:-contains-key? {:name -contains-key?, :arglists ([coll k]), :doc "Returns true if k is a key in coll."}, :-assoc {:name -assoc, :arglists ([coll k v]), :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :doc "Protocol for adding associativity to collections.", :jsdoc ("@interface")}, ->Single {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 16, :column 10, :factory :positional, :line 4094, :end-line 4094, :arglists (quote ([val])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/Single."}, :protocols #{cljs.core/Object}, :name cljs.core/->Single, :file "cljs/core.cljs", :end-column 16, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4094, :ret-tag cljs.core/Single, :end-line 4094, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/Single."}, bit-flip {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2892, :column 7, :end-line 2892, :end-column 15, :arglists (quote ([x n])), :doc "Flip bit at index n"}, :name cljs.core/bit-flip, :file "cljs/core.cljs", :end-column 15, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2892, :ret-tag number, :end-line 2892, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Flip bit at index n"}, long-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3701, :column 7, :end-line 3701, :end-column 17, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size-or-seq] [size init-val-or-seq]], :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/long-array, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size-or-seq] [size init-val-or-seq]], :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params [[size-or-seq] [size init-val-or-seq]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag #{any array}} {:fixed-arity 2, :variadic? false, :tag array}], :line 3701, :end-line 3701, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure."}, descendants {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10915, :column 7, :end-line 10915, :end-column 18, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tag] [h tag]], :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/descendants, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tag] [h tag]], :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params [[tag] [h tag]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag #{nil clj-nil}}], :line 10915, :end-line 10915, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships."}, imul {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 912, :column 17, :end-line 912, :end-column 21, :tag number, :arglists (quote ([a b]))}, :name cljs.core/imul, :file "cljs/core.cljs", :end-column 21, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :variadic? false, :line 912, :ret-tag number, :end-line 912, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([a b]))}, ->Delay {:protocol-inline nil, :meta {:protocols #{cljs.core/IPending cljs.core/IDeref cljs.core/IPrintWithWriter}, :file "cljs/core.cljs", :end-column 15, :column 10, :factory :positional, :line 10568, :end-line 10568, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref cljs.core/IPrintWithWriter}, :doc "Positional factory function for cljs.core/Delay."}, :protocols #{cljs.core/IPending cljs.core/IDeref cljs.core/IPrintWithWriter}, :name cljs.core/->Delay, :file "cljs/core.cljs", :end-column 15, :method-params ([f value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 10568, :ret-tag cljs.core/Delay, :end-line 10568, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref cljs.core/IPrintWithWriter}, :doc "Positional factory function for cljs.core/Delay."}, array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5428, :column 8, :end-line 5428, :end-column 17, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/array-for, :file "cljs/core.cljs", :end-column 17, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5428, :ret-tag any, :end-line 5428, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, merge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9109, :column 7, :end-line 9109, :end-column 12, :arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}}, :name cljs.core/merge, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}, :method-params [(maps)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag #{nil any clj-nil}}], :line 9109, :ret-tag any, :end-line 9109, :max-fixed-arity 0, :fn-var true, :arglists ([& maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result."}, ISeqable {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 22, :column 14, :line 727, :protocol-info {:methods {-seq [[o]]}}, :end-line 727, :sigs {:-seq {:name -seq, :arglists ([o]), :doc "Returns a seq of o, or nil if o is empty."}}, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ISeqable, :file "cljs/core.cljs", :end-column 22, :column 1, :line 727, :protocol-info {:methods {-seq [[o]]}}, :info nil, :end-line 727, :tag any, :sigs {:-seq {:name -seq, :arglists ([o]), :doc "Returns a seq of o, or nil if o is empty."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/Cycle cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/Iterate cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :jsdoc ("@interface")}, Empty {:num-fields 0, :protocols #{cljs.core/Object}, :name cljs.core/Empty, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 4113, :record false, :end-line 4113, :tag function, :skip-protocol-flag nil}, js-mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2841, :column 7, :end-line 2841, :end-column 13, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, :name cljs.core/js-mod, :file "cljs/core.cljs", :end-column 13, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2841, :ret-tag number, :end-line 2841, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, ->RangeChunk {:protocol-inline nil, :meta {:protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/ISeq cljs.core/IChunk}, :file "cljs/core.cljs", :end-column 20, :column 10, :factory :positional, :line 9653, :end-line 9653, :arglists (quote ([start step count])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/ISeq}, :doc "Positional factory function for cljs.core/RangeChunk."}, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/ISeq cljs.core/IChunk}, :name cljs.core/->RangeChunk, :file "cljs/core.cljs", :end-column 20, :method-params ([start step count]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 9653, :ret-tag cljs.core/RangeChunk, :end-line 9653, :max-fixed-arity 3, :fn-var true, :arglists (quote ([start step count])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/ISeq}, :doc "Positional factory function for cljs.core/RangeChunk."}, integer? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2275, :column 7, :end-line 2275, :end-column 15, :arglists (quote ([n])), :doc "Returns true if n is a JavaScript number with no decimal part."}, :name cljs.core/integer?, :file "cljs/core.cljs", :end-column 15, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2275, :ret-tag boolean, :end-line 2275, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is a JavaScript number with no decimal part."}, MetaFn {:num-fields 2, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/MetaFn, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 2029, :record false, :end-line 2029, :tag function, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, NS_CACHE {:meta {:file "cljs/core.cljs", :line 11611, :column 3, :end-line 11611, :end-column 11, :doc "Bootstrap only.", :jsdoc ["@type {*}"]}, :name cljs.core/NS_CACHE, :file "cljs/core.cljs", :end-column 11, :column 1, :line 11609, :end-line 11611, :tag clj-nil, :doc "Bootstrap only.", :jsdoc ["@type {*}"]}, mapv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5240, :column 7, :end-line 5240, :end-column 11, :arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[f coll] [f c1 c2] [f c1 c2 c3]], :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/mapv, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[f coll] [f c1 c2] [f c1 c2 c3]], :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}, :method-params [[f coll] [f c1 c2] [f c1 c2 c3]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag clj} {:fixed-arity 3, :variadic? false, :tag #{nil clj any}} {:fixed-arity 4, :variadic? false, :tag #{nil clj any}} {:fixed-arity 4, :variadic? true, :tag #{nil clj any}}], :line 5240, :end-line 5240, :max-fixed-arity 4, :fn-var true, :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments."}, infinite? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2346, :column 7, :end-line 2346, :end-column 16, :arglists (quote ([x])), :doc "Returns true for Infinity and -Infinity values."}, :name cljs.core/infinite?, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2346, :ret-tag boolean, :end-line 2346, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true for Infinity and -Infinity values."}, partition-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9567, :column 7, :end-line 9567, :end-column 20, :arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[n] [n coll] [n step coll]], :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition-all, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[n] [n coll] [n step coll]], :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}, :method-params [[n] [n coll] [n step coll]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag cljs.core/LazySeq}], :line 9567, :end-line 9567, :max-fixed-arity 3, :fn-var true, :arglists ([n] [n coll] [n step coll]), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided."}, partition-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9851, :column 7, :end-line 9851, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f coll]], :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/partition-by, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f coll]], :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params [[f] [f coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 9851, :end-line 9851, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided."}, ISequential {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 25, :column 14, :line 732, :protocol-info {:methods {}}, :end-line 732, :sigs {}, :doc "Marker interface indicating a persistent collection of sequential items", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ISequential, :file "cljs/core.cljs", :end-column 25, :column 1, :line 732, :protocol-info {:methods {}}, :info nil, :end-line 732, :tag any, :sigs {}, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/Cycle cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/Iterate cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Marker interface indicating a persistent collection of sequential items", :jsdoc ("@interface")}, ->LazySeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 17, :column 10, :factory :positional, :line 3429, :end-line 3429, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/LazySeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->LazySeq, :file "cljs/core.cljs", :end-column 17, :method-params ([meta fn s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 3429, :ret-tag cljs.core/LazySeq, :end-line 3429, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/LazySeq."}, equiv-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6346, :column 7, :end-line 6346, :end-column 16, :arglists (quote ([x y])), :doc "Test map equivalence. Returns true if x equals y, otherwise returns false."}, :name cljs.core/equiv-map, :file "cljs/core.cljs", :end-column 16, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6346, :ret-tag boolean, :end-line 6346, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Test map equivalence. Returns true if x equals y, otherwise returns false."}, ->Volatile {:protocol-inline nil, :meta {:protocols #{cljs.core/IVolatile cljs.core/IDeref}, :file "cljs/core.cljs", :end-column 18, :column 10, :factory :positional, :line 4574, :end-line 4574, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}, :doc "Positional factory function for cljs.core/Volatile."}, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/->Volatile, :file "cljs/core.cljs", :end-column 18, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4574, :ret-tag cljs.core/Volatile, :end-line 4574, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}, :doc "Positional factory function for cljs.core/Volatile."}, object-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3745, :column 7, :end-line 3745, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size-or-seq] [size init-val-or-seq]], :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/object-array, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size-or-seq] [size init-val-or-seq]], :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params [[size-or-seq] [size init-val-or-seq]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag #{any array}} {:fixed-arity 2, :variadic? false, :tag array}], :line 3745, :end-line 3745, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure."}, Keyword {:meta {:file "cljs/core.cljs", :line 228, :column 20, :end-line 228, :end-column 27, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/Keyword, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3318, :record false, :declared true, :end-line 3318, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, derive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10924, :column 7, :end-line 10924, :end-column 13, :arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[tag parent] [h tag parent]], :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/derive, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[tag parent] [h tag parent]], :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params [[tag parent] [h tag parent]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag clj-nil} {:fixed-arity 3, :variadic? false, :tag #{nil cljs.core/IMap}}], :line 10924, :end-line 10924, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, seq-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4068, :column 7, :end-line 4068, :end-column 15, :arglists (quote ([coll]))}, :name cljs.core/seq-iter, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4068, :ret-tag cljs.core/SeqIter, :end-line 4068, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, ->Empty {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 15, :column 10, :factory :positional, :line 4113, :end-line 4113, :arglists (quote ([])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/Empty."}, :protocols #{cljs.core/Object}, :name cljs.core/->Empty, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4113, :ret-tag cljs.core/Empty, :end-line 4113, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/Empty."}, IChunkedSeq {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 25, :column 14, :line 840, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :end-line 840, :sigs {:-chunked-first {:name -chunked-first, :arglists ([coll]), :doc "Returns the first chunk in coll."}, :-chunked-rest {:name -chunked-rest, :arglists ([coll]), :doc "Return a new collection of coll with the first chunk removed."}}, :doc "Protocol for accessing a collection as sequential chunks.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IChunkedSeq, :file "cljs/core.cljs", :end-column 25, :column 1, :line 840, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :info nil, :end-line 840, :tag any, :sigs {:-chunked-first {:name -chunked-first, :arglists ([coll]), :doc "Returns the first chunk in coll."}, :-chunked-rest {:name -chunked-rest, :arglists ([coll]), :doc "Return a new collection of coll with the first chunk removed."}}, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/Range}, :doc "Protocol for accessing a collection as sequential chunks.", :jsdoc ("@interface")}, special-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11396, :column 16, :end-line 11396, :end-column 31, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x names a special form"}, :name cljs.core/special-symbol?, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11396, :ret-tag boolean, :end-line 11396, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x names a special form"}, compare-keywords {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3306, :column 8, :end-line 3306, :end-column 24, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-keywords, :file "cljs/core.cljs", :end-column 24, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3306, :ret-tag number, :end-line 3306, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, ancestors {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10907, :column 7, :end-line 10907, :end-column 16, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tag] [h tag]], :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/ancestors, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tag] [h tag]], :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params [[tag] [h tag]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag #{nil clj-nil}}], :line 10907, :end-line 10907, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, subseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9623, :column 7, :end-line 9623, :end-column 13, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[sc test key] [sc start-test start-key end-test end-key]], :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/subseq, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[sc test key] [sc start-test start-key end-test end-key]], :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params [[sc test key] [sc start-test start-key end-test end-key]], :protocol-impl nil, :fixed-arity 5, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 3, :variadic? false, :tag #{seq clj cljs.core/LazySeq clj-nil}} {:fixed-arity 5, :variadic? false, :tag #{cljs.core/LazySeq clj-nil}}], :line 9623, :end-line 9623, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, gensym {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10556, :column 7, :end-line 10556, :end-column 13, :arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [prefix-string]], :arglists ([] [prefix-string]), :arglists-meta (nil nil)}}, :name cljs.core/gensym, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [prefix-string]], :arglists ([] [prefix-string]), :arglists-meta (nil nil)}, :method-params [[] [prefix-string]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 0, :variadic? false, :tag any} {:fixed-arity 1, :variadic? false, :tag #{any cljs.core/Symbol}}], :line 10556, :end-line 10556, :max-fixed-arity 1, :fn-var true, :arglists ([] [prefix-string]), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'."}, -next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 626, :column 16, :end-line 626, :end-column 21, :tag clj-or-nil, :protocol cljs.core/INext, :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists (quote ([coll]))}, :protocol cljs.core/INext, :name cljs.core/-next, :file "cljs/core.cljs", :end-column 21, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 624, :ret-tag clj-or-nil, :end-line 626, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil"}, ->HashCollisionNode {:protocol-inline nil, :meta {:protocols #{cljs.core/Object cljs.core/IIterable}, :file "cljs/core.cljs", :end-column 27, :column 10, :factory :positional, :line 7589, :end-line 7589, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag #{cljs.core/IIterable}, :doc "Positional factory function for cljs.core/HashCollisionNode."}, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/->HashCollisionNode, :file "cljs/core.cljs", :end-column 27, :method-params ([edit collision-hash cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 7589, :ret-tag cljs.core/HashCollisionNode, :end-line 7589, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag #{cljs.core/IIterable}, :doc "Positional factory function for cljs.core/HashCollisionNode."}, delay? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10586, :column 7, :end-line 10586, :end-column 13, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, :name cljs.core/delay?, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10586, :ret-tag boolean, :end-line 10586, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, create-inode-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7773, :column 8, :end-line 7773, :end-column 24, :private true, :arglists (quote ([nodes] [nodes i s])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[nodes] [nodes i s]], :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-inode-seq, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[nodes] [nodes i s]], :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}, :method-params [[nodes] [nodes i s]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag #{cljs.core/NodeSeq clj-nil}}], :line 7773, :end-line 7773, :max-fixed-arity 3, :fn-var true, :arglists ([nodes] [nodes i s])}, flatten {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5216, :column 7, :end-line 5216, :end-column 14, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, :name cljs.core/flatten, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5216, :ret-tag cljs.core/LazySeq, :end-line 5216, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, -dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 654, :column 9, :end-line 654, :end-column 16, :tag clj, :protocol cljs.core/IMap, :doc "Returns a new collection of coll without the mapping for key k.", :arglists (quote ([coll k]))}, :protocol cljs.core/IMap, :name cljs.core/-dissoc, :file "cljs/core.cljs", :end-column 16, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 651, :ret-tag clj, :end-line 654, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll k])), :doc "Returns a new collection of coll without the mapping for key k."}, doubles {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2838, :column 7, :end-line 2838, :end-column 14, :arglists (quote ([x]))}, :name cljs.core/doubles, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2838, :end-line 2838, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, halt-when {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10621, :column 7, :end-line 10621, :end-column 16, :arglists (quote ([pred] [pred retf])), :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", :added "1.9", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred retf]], :arglists ([pred] [pred retf]), :arglists-meta (nil nil)}}, :added "1.9", :name cljs.core/halt-when, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred retf]], :arglists ([pred] [pred retf]), :arglists-meta (nil nil)}, :method-params [[pred] [pred retf]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag function}], :line 10621, :end-line 10621, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred retf]), :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected."}, -contains-key? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 640, :column 13, :end-line 640, :end-column 27, :tag boolean, :protocol cljs.core/IAssociative, :doc "Returns true if k is a key in coll.", :arglists (quote ([coll k]))}, :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :file "cljs/core.cljs", :end-column 27, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 638, :ret-tag boolean, :end-line 640, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll k])), :doc "Returns true if k is a key in coll."}, remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10544, :column 7, :end-line 10544, :end-column 19, :arglists (quote ([iref key])), :doc "Removes a watch (set by add-watch) from a reference"}, :name cljs.core/remove-watch, :file "cljs/core.cljs", :end-column 19, :method-params ([iref key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10544, :end-line 10544, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref key])), :doc "Removes a watch (set by add-watch) from a reference"}, ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11361, :column 7, :end-line 11361, :end-column 14, :arglists (quote ([msg data] [msg data cause])), :doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[msg data] [msg data cause]], :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}}, :name cljs.core/ex-info, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[msg data] [msg data cause]], :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}, :method-params [[msg data] [msg data cause]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag cljs.core/ExceptionInfo}], :line 11361, :end-line 11361, :max-fixed-arity 3, :fn-var true, :arglists ([msg data] [msg data cause]), :doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data."}, ifn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2270, :column 7, :end-line 2270, :end-column 11, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, :name cljs.core/ifn?, :file "cljs/core.cljs", :end-column 11, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2270, :ret-tag boolean, :end-line 2270, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, IAtom {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 19, :column 14, :line 859, :protocol-info {:methods {}}, :end-line 859, :sigs {}, :doc "Marker protocol indicating an atom.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IAtom, :file "cljs/core.cljs", :end-column 19, :column 1, :line 859, :protocol-info {:methods {}}, :info nil, :end-line 859, :tag any, :sigs {}, :impls #{cljs.core/Atom}, :doc "Marker protocol indicating an atom.", :jsdoc ("@interface")}, ->PersistentQueue {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :file "cljs/core.cljs", :end-column 25, :column 10, :factory :positional, :line 6264, :end-line 6264, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/PersistentQueue."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueue, :file "cljs/core.cljs", :end-column 25, :method-params ([meta count front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6264, :ret-tag cljs.core/PersistentQueue, :end-line 6264, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/PersistentQueue."}, nat-int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2321, :column 7, :end-line 2321, :end-column 15, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is a natural integer value."}, :name cljs.core/nat-int?, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2321, :ret-tag boolean, :end-line 2321, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is a natural integer value."}, IWatchable {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 24, :column 14, :line 784, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :end-line 784, :sigs {:-notify-watches {:name -notify-watches, :arglists ([this oldval newval]), :doc "Calls all watchers with this, oldval and newval."}, :-add-watch {:name -add-watch, :arglists ([this key f]), :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch."}, :-remove-watch {:name -remove-watch, :arglists ([this key]), :doc "Removes watcher that corresponds to key from this."}}, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IWatchable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 784, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :info nil, :end-line 784, :tag any, :sigs {:-notify-watches {:name -notify-watches, :arglists ([this oldval newval]), :doc "Calls all watchers with this, oldval and newval."}, :-add-watch {:name -add-watch, :arglists ([this key f]), :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch."}, :-remove-watch {:name -remove-watch, :arglists ([this key]), :doc "Removes watcher that corresponds to key from this."}}, :impls #{cljs.core/Atom}, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :jsdoc ("@interface")}, pv-fresh-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5362, :column 8, :end-line 5362, :end-column 21, :private true, :arglists (quote ([edit]))}, :private true, :name cljs.core/pv-fresh-node, :file "cljs/core.cljs", :end-column 21, :method-params ([edit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5362, :ret-tag cljs.core/VectorNode, :end-line 5362, :max-fixed-arity 1, :fn-var true, :arglists (quote ([edit]))}, subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5989, :column 7, :end-line 5989, :end-column 13, :arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[v start] [v start end]], :arglists ([v start] [v start end]), :arglists-meta (nil nil)}}, :name cljs.core/subvec, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[v start] [v start end]], :arglists ([v start] [v start end]), :arglists-meta (nil nil)}, :method-params [[v start] [v start end]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag cljs.core/Subvec}], :line 5989, :end-line 5989, :max-fixed-arity 3, :fn-var true, :arglists ([v start] [v start end]), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done."}, -pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 821, :column 9, :end-line 821, :end-column 14, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with the last item removed from it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :file "cljs/core.cljs", :end-column 14, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 817, :ret-tag clj, :end-line 821, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns tcoll with the last item removed from it."}, partial {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4315, :column 7, :end-line 4315, :end-column 14, :arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]], :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/partial, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 4, :max-fixed-arity 4, :method-params [[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]], :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}, :method-params [[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]], :protocol-impl nil, :fixed-arity 4, :arglists-meta (nil nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag function} {:fixed-arity 3, :variadic? false, :tag function} {:fixed-arity 4, :variadic? false, :tag function} {:fixed-arity 4, :variadic? true, :tag function}], :line 4315, :end-line 4315, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args."}, chunked-seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2185, :column 7, :end-line 2185, :end-column 19, :arglists (quote ([x])), :doc "Return true if x satisfies IChunkedSeq."}, :name cljs.core/chunked-seq?, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2185, :ret-tag boolean, :end-line 2185, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IChunkedSeq."}, replicate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5024, :column 7, :end-line 5024, :end-column 16, :arglists (quote ([n x])), :doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs."}, :name cljs.core/replicate, :file "cljs/core.cljs", :end-column 16, :method-params ([n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5024, :ret-tag cljs.core/LazySeq, :end-line 5024, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n x])), :doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs."}, PersistentQueue {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueue, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 6264, :record false, :end-line 6264, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}}, min-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9547, :column 7, :end-line 9547, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[k x] [k x y]], :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min-key, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[k x] [k x y]], :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params [[k x] [k x y]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false} {:fixed-arity 3, :variadic? false} {:fixed-arity 3, :variadic? true, :tag #{nil any}}], :line 9547, :end-line 9547, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned."}, hash-iset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3029, :column 8, :end-line 3029, :end-column 17, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/hash-iset, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3029, :ret-tag number, :end-line 3029, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1447, :column 7, :end-line 1447, :end-column 14, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, :name cljs.core/reduced, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1447, :ret-tag cljs.core/Reduced, :end-line 1447, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, re-matches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9987, :column 7, :end-line 9987, :end-column 17, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, :name cljs.core/re-matches, :file "cljs/core.cljs", :end-column 17, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9987, :ret-tag #{clj cljs.core/IVector any cljs.core/MetaFn clj-nil}, :end-line 9987, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, pr-writer-impl {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10107, :column 8, :end-line 10107, :end-column 22, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-impl, :file "cljs/core.cljs", :end-column 22, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10107, :ret-tag #{any clj-nil}, :end-line 10107, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, array-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8910, :column 7, :end-line 8910, :end-column 16, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/array-map, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag any}], :line 8910, :ret-tag any, :end-line 8910, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new array map with supplied mappings."}, ITransientSet {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 27, :column 14, :line 824, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :end-line 824, :sigs {:-disjoin! {:name -disjoin!, :arglists ([tcoll v]), :doc "Returns tcoll without v."}}, :doc "Protocol for adding set functionality to a transient collection.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ITransientSet, :file "cljs/core.cljs", :end-column 27, :column 1, :line 824, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :info nil, :end-line 824, :tag any, :sigs {:-disjoin! {:name -disjoin!, :arglists ([tcoll v]), :doc "Returns tcoll without v."}}, :impls #{cljs.core/TransientHashSet}, :doc "Protocol for adding set functionality to a transient collection.", :jsdoc ("@interface")}, ITER_SYMBOL {:name cljs.core/ITER_SYMBOL, :file "cljs/core.cljs", :line 339, :column 3, :end-line 339, :end-column 19, :meta {:file "cljs/core.cljs", :line 339, :column 8, :end-line 339, :end-column 19}, :tag string}, unchecked-byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2725, :column 15, :end-line 2725, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-byte, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2725, :ret-tag number, :end-line 2725, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, checked-aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 472, :column 8, :end-line 472, :end-column 20, :private true, :arglists (quote ([array idx val] [array idx idx2 & idxv])), :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[array idx val]], :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/checked-aset, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[array idx val]], :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params [[array idx val]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 3, :variadic? false, :tag any} {:fixed-arity 3, :variadic? true, :tag any}], :line 472, :end-line 472, :max-fixed-arity 3, :fn-var true, :arglists ([array idx val] [array idx idx2 & idxv])}, ArrayNode {:meta {:file "cljs/core.cljs", :line 7204, :column 10, :end-line 7204, :end-column 19, :declared true}, :num-fields 3, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/ArrayNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 7479, :record false, :declared true, :end-line 7479, :tag function, :skip-protocol-flag #{cljs.core/IIterable}}, ->ChunkedSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 20, :column 10, :factory :positional, :line 5746, :end-line 5746, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/ChunkedSeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ChunkedSeq, :file "cljs/core.cljs", :end-column 20, :method-params ([vec node i off meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 5746, :ret-tag cljs.core/ChunkedSeq, :end-line 5746, :max-fixed-arity 6, :fn-var true, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/ChunkedSeq."}, every-pred {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4632, :column 7, :end-line 4632, :end-column 17, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[p] [p1 p2] [p1 p2 p3]], :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/every-pred, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[p] [p1 p2] [p1 p2 p3]], :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params [[p] [p1 p2] [p1 p2 p3]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag function} {:fixed-arity 3, :variadic? false, :tag function} {:fixed-arity 3, :variadic? true, :tag function}], :line 4632, :end-line 4632, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates."}, keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9019, :column 7, :end-line 9019, :end-column 11, :arglists (quote ([map])), :doc "Returns a sequence of the map's keys, in the same order as (seq map)."}, :name cljs.core/keys, :file "cljs/core.cljs", :end-column 11, :method-params ([map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9019, :ret-tag #{cljs.core/KeySeq clj-nil}, :end-line 9019, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map])), :doc "Returns a sequence of the map's keys, in the same order as (seq map)."}, missing-protocol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 317, :column 7, :end-line 317, :end-column 23, :arglists (quote ([proto obj]))}, :name cljs.core/missing-protocol, :file "cljs/core.cljs", :end-column 23, :method-params ([proto obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 317, :ret-tag js/Error, :end-line 317, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proto obj]))}, load-file {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 332, :column 7, :end-line 332, :end-column 16, :arglists (quote ([file]))}, :name cljs.core/load-file, :file "cljs/core.cljs", :end-column 16, :method-params ([file]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 332, :ret-tag #{any clj-nil}, :end-line 332, :max-fixed-arity 1, :fn-var true, :arglists (quote ([file]))}, PersistentArrayMap {:meta {:file "cljs/core.cljs", :line 1991, :column 28, :end-line 1991, :end-column 46, :declared true}, :num-fields 4, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentArrayMap, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6829, :record false, :declared true, :end-line 6829, :tag function, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, distinct? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2373, :column 16, :end-line 2373, :end-column 25, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are =", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/distinct?, :file "cljs/core.cljs", :end-column 25, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? true, :tag boolean}], :line 2373, :ret-tag boolean, :end-line 2373, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns true if no two of the arguments are ="}, pos-int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2291, :column 7, :end-line 2291, :end-column 15, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is positive."}, :name cljs.core/pos-int?, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2291, :ret-tag boolean, :end-line 2291, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is positive."}, never-equiv {:name cljs.core/never-equiv, :file "cljs/core.cljs", :line 6344, :column 1, :end-line 6344, :end-column 27, :private true, :meta {:file "cljs/core.cljs", :line 6344, :column 16, :end-line 6344, :end-column 27, :private true}, :tag cljs.core/NeverEquiv}, unchecked-short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2727, :column 15, :end-line 2727, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-short, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2727, :ret-tag number, :end-line 2727, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ->Range {:protocol-inline nil, :meta {:protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 15, :column 10, :factory :positional, :line 9685, :end-line 9685, :arglists (quote ([meta start end step chunk chunk-next __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Range."}, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Range, :file "cljs/core.cljs", :end-column 15, :method-params ([meta start end step chunk chunk-next __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 9685, :ret-tag cljs.core/Range, :end-line 9685, :max-fixed-arity 7, :fn-var true, :arglists (quote ([meta start end step chunk chunk-next __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Range."}, ->MapEntry {:protocol-inline nil, :meta {:protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 18, :column 10, :factory :positional, :line 6649, :end-line 6649, :arglists (quote ([key val __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/MapEntry."}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->MapEntry, :file "cljs/core.cljs", :end-column 18, :method-params ([key val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6649, :ret-tag cljs.core/MapEntry, :end-line 6649, :max-fixed-arity 3, :fn-var true, :arglists (quote ([key val __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/MapEntry."}, apply-to-simple {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3905, :column 8, :end-line 3905, :end-column 23, :private true, :arglists (quote ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args])), :doc "Internal. DO NOT USE!\n  Assumes args was already called with seq beforehand!", :top-fn {:variadic? false, :fixed-arity 6, :max-fixed-arity 6, :method-params [[f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]], :arglists ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]), :arglists-meta (nil nil nil nil nil)}}, :private true, :name cljs.core/apply-to-simple, :file "cljs/core.cljs", :end-column 23, :top-fn {:variadic? false, :fixed-arity 6, :max-fixed-arity 6, :method-params [[f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]], :arglists ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]), :arglists-meta (nil nil nil nil nil)}, :method-params [[f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]], :protocol-impl nil, :fixed-arity 6, :arglists-meta (nil nil nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag any} {:fixed-arity 4, :variadic? false, :tag any} {:fixed-arity 5, :variadic? false, :tag any} {:fixed-arity 6, :variadic? false, :tag any}], :line 3905, :end-line 3905, :max-fixed-arity 6, :fn-var true, :arglists ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]), :doc "Internal. DO NOT USE!\n  Assumes args was already called with seq beforehand!"}, methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11249, :column 7, :end-line 11249, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, :name cljs.core/methods, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11249, :ret-tag any, :end-line 11249, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, odd? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4268, :column 7, :end-line 4268, :end-column 11, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, :name cljs.core/odd?, :file "cljs/core.cljs", :end-column 11, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4268, :ret-tag boolean, :end-line 4268, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, ->ArrayChunk {:protocol-inline nil, :meta {:protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 20, :column 10, :factory :positional, :line 3529, :end-line 3529, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :doc "Positional factory function for cljs.core/ArrayChunk."}, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/->ArrayChunk, :file "cljs/core.cljs", :end-column 20, :method-params ([arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 3529, :ret-tag cljs.core/ArrayChunk, :end-line 3529, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :doc "Positional factory function for cljs.core/ArrayChunk."}, ci-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1477, :column 8, :end-line 1477, :end-column 17, :private true, :arglists (quote ([cicoll f] [cicoll f val])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[cicoll f] [cicoll f val]], :arglists ([cicoll f] [cicoll f val]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/ci-reduce, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[cicoll f] [cicoll f val]], :arglists ([cicoll f] [cicoll f val]), :arglists-meta (nil nil)}, :method-params [[cicoll f] [cicoll f val]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag #{nil any}}], :line 1477, :end-line 1477, :max-fixed-arity 3, :fn-var true, :arglists ([cicoll f] [cicoll f val]), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization"}, *3 {:name cljs.core/*3, :file "cljs/core.cljs", :line 213, :column 1, :end-line 215, :end-column 5, :doc "bound in a repl thread to the third most recent value printed", :meta {:file "cljs/core.cljs", :line 215, :column 3, :end-line 215, :end-column 5, :doc "bound in a repl thread to the third most recent value printed"}}, -get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11039, :column 4, :end-line 11039, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11034, :ret-tag any, :end-line 11039, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->Var {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :file "cljs/core.cljs", :end-column 13, :column 10, :factory :positional, :line 1131, :end-line 1131, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/Var."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :name cljs.core/->Var, :file "cljs/core.cljs", :end-column 13, :method-params ([val sym _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 1131, :ret-tag cljs.core/Var, :end-line 1131, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/Var."}, frequencies {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9892, :column 7, :end-line 9892, :end-column 18, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, :name cljs.core/frequencies, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9892, :ret-tag clj, :end-line 9892, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, reduceable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2163, :column 7, :end-line 2163, :end-column 18, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, :name cljs.core/reduceable?, :file "cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2163, :ret-tag boolean, :end-line 2163, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, string-hash-cache {:name cljs.core/string-hash-cache, :file "cljs/core.cljs", :line 968, :column 1, :end-line 968, :end-column 23, :meta {:file "cljs/core.cljs", :line 968, :column 6, :end-line 968, :end-column 23}, :tag object}, ->Iterate {:protocol-inline nil, :meta {:protocols #{cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 17, :column 10, :factory :positional, :line 5038, :end-line 5038, :arglists (quote ([meta f prev-seed seed next])), :skip-protocol-flag #{cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Iterate."}, :protocols #{cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Iterate, :file "cljs/core.cljs", :end-column 17, :method-params ([meta f prev-seed seed next]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 5038, :ret-tag cljs.core/Iterate, :end-line 5038, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta f prev-seed seed next])), :skip-protocol-flag #{cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Iterate."}, rsubseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9638, :column 7, :end-line 9638, :end-column 14, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[sc test key] [sc start-test start-key end-test end-key]], :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/rsubseq, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[sc test key] [sc start-test start-key end-test end-key]], :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params [[sc test key] [sc start-test start-key end-test end-key]], :protocol-impl nil, :fixed-arity 5, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 3, :variadic? false, :tag #{seq clj cljs.core/LazySeq clj-nil}} {:fixed-arity 5, :variadic? false, :tag #{cljs.core/LazySeq clj-nil}}], :line 9638, :end-line 9638, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1437, :column 7, :end-line 1437, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, :name cljs.core/inc, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1437, :ret-tag number, :end-line 1437, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, type->str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 326, :column 7, :end-line 326, :end-column 16, :arglists (quote ([ty]))}, :name cljs.core/type->str, :file "cljs/core.cljs", :end-column 16, :method-params ([ty]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 326, :ret-tag #{any string}, :end-line 326, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ty]))}, obj-clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6402, :column 8, :end-line 6402, :end-column 17, :private true, :arglists (quote ([obj ks]))}, :private true, :name cljs.core/obj-clone, :file "cljs/core.cljs", :end-column 17, :method-params ([obj ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6402, :ret-tag object, :end-line 6402, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj ks]))}, get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11253, :column 7, :end-line 11253, :end-column 17, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, :name cljs.core/get-method, :file "cljs/core.cljs", :end-column 17, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11253, :ret-tag any, :end-line 11253, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, uuid? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11316, :column 7, :end-line 11316, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/uuid?, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11316, :ret-tag boolean, :end-line 11316, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, vector-index-out-of-bounds {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5406, :column 8, :end-line 5406, :end-column 34, :private true, :arglists (quote ([i cnt]))}, :private true, :name cljs.core/vector-index-out-of-bounds, :file "cljs/core.cljs", :end-column 34, :method-params ([i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5406, :ret-tag ignore, :end-line 5406, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i cnt]))}, es6-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6554, :column 7, :end-line 6554, :end-column 27, :arglists (quote ([coll]))}, :name cljs.core/es6-entries-iterator, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6554, :ret-tag cljs.core/ES6EntriesIterator, :end-line 6554, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, bit-clear {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2887, :column 7, :end-line 2887, :end-column 16, :arglists (quote ([x n])), :doc "Clear bit at index n"}, :name cljs.core/bit-clear, :file "cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2887, :ret-tag number, :end-line 2887, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Clear bit at index n"}, Range {:num-fields 7, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Range, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 9685, :record false, :end-line 9685, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, filter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5164, :column 7, :end-line 5164, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred coll]], :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/filter, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred coll]], :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params [[pred] [pred coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 5164, :end-line 5164, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->PersistentTreeMapSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 30, :column 10, :factory :positional, :line 8174, :end-line 8174, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/PersistentTreeMapSeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentTreeMapSeq, :file "cljs/core.cljs", :end-column 30, :method-params ([meta stack ascending? cnt __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 8174, :ret-tag cljs.core/PersistentTreeMapSeq, :end-line 8174, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/PersistentTreeMapSeq."}, create-array-node-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7846, :column 8, :end-line 7846, :end-column 29, :private true, :arglists (quote ([nodes] [nodes i s])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[nodes] [nodes i s]], :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-array-node-seq, :file "cljs/core.cljs", :end-column 29, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[nodes] [nodes i s]], :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}, :method-params [[nodes] [nodes i s]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag #{cljs.core/ArrayNodeSeq clj-nil}}], :line 7846, :end-line 7846, :max-fixed-arity 3, :fn-var true, :arglists ([nodes] [nodes i s])}, -assoc-n! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 819, :column 9, :end-line 819, :end-column 18, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with value val added at position n.", :arglists (quote ([tcoll n val]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 817, :ret-tag clj, :end-line 819, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll n val])), :doc "Returns tcoll with value val added at position n."}, IWithMeta {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 23, :column 14, :line 697, :protocol-info {:methods {-with-meta [[o meta]]}}, :end-line 697, :sigs {:-with-meta {:name -with-meta, :arglists ([o meta]), :doc "Returns a new object with value of o and metadata meta added to it."}}, :doc "Protocol for adding metadata to an object.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IWithMeta, :file "cljs/core.cljs", :end-column 23, :column 1, :line 697, :protocol-info {:methods {-with-meta [[o meta]]}}, :info nil, :end-line 697, :tag any, :sigs {:-with-meta {:name -with-meta, :arglists ([o meta]), :doc "Returns a new object with value of o and metadata meta added to it."}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/t_cljs$core11293 cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/Cycle cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/Iterate cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding metadata to an object.", :jsdoc ("@interface")}, next* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3898, :column 13, :end-line 3898, :end-column 18, :tag seq, :private true, :arglists (quote ([coll])), :doc "Internal. DO NOT USE! Next without the nil? check."}, :private true, :name cljs.core/next*, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3898, :ret-tag seq, :end-line 3898, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Internal. DO NOT USE! Next without the nil? check."}, list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3218, :column 7, :end-line 3218, :end-column 11, :arglists (quote ([& xs])), :doc "Creates a new list containing the items.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}}, :name cljs.core/list, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}, :method-params [(xs)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag #{clj cljs.core/IList}}], :line 3218, :ret-tag any, :end-line 3218, :max-fixed-arity 0, :fn-var true, :arglists ([& xs]), :doc "Creates a new list containing the items."}, + {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2614, :column 15, :end-line 2614, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/+, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[] [x] [x y]], :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params [[] [x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag number} {:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag number} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2614, :ret-tag number, :end-line 2614, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, IndexedSeqIterator {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/IndexedSeqIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 1576, :record false, :end-line 1576, :tag function, :skip-protocol-flag nil}, split-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9846, :column 7, :end-line 9846, :end-column 17, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, :name cljs.core/split-with, :file "cljs/core.cljs", :end-column 17, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9846, :ret-tag cljs.core/IVector, :end-line 9846, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, ->VectorNode {:protocol-inline nil, :meta {:protocols #{}, :file "cljs/core.cljs", :end-column 20, :column 10, :factory :positional, :line 5360, :end-line 5360, :arglists (quote ([edit arr])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/VectorNode."}, :protocols #{}, :name cljs.core/->VectorNode, :file "cljs/core.cljs", :end-column 20, :method-params ([edit arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 5360, :ret-tag cljs.core/VectorNode, :end-line 5360, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit arr])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/VectorNode."}, aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 509, :column 7, :end-line 509, :end-column 11, :arglists (quote ([array idx val] [array idx idx2 & idxv])), :doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[array idx val]], :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}}, :name cljs.core/aset, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[array idx val]], :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params [[array idx val]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 3, :variadic? false, :tag any} {:fixed-arity 3, :variadic? true, :tag any}], :line 509, :end-line 509, :max-fixed-arity 3, :fn-var true, :arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val."}, int-rotate-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 903, :column 15, :end-line 903, :end-column 30, :tag number, :arglists (quote ([x n]))}, :name cljs.core/int-rotate-left, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 903, :ret-tag number, :end-line 903, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x n]))}, keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3404, :column 7, :end-line 3404, :end-column 14, :arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[name] [ns name]], :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/keyword, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[name] [ns name]], :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params [[name] [ns name]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag #{cljs.core/Keyword clj-nil}} {:fixed-arity 2, :variadic? false, :tag cljs.core/Keyword}], :line 3404, :end-line 3404, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name]), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically."}, ->Cons {:protocol-inline nil, :meta {:protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 14, :column 10, :factory :positional, :line 3235, :end-line 3235, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Cons."}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cons, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 3235, :ret-tag cljs.core/Cons, :end-line 3235, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Cons."}, *ns* {:meta {:file "cljs/core.cljs", :line 60, :column 3, :end-line 60, :end-column 7, :dynamic true, :doc "Var bound to the current namespace. Only used for bootstrapping.", :jsdoc ["@type {*}"]}, :name cljs.core/*ns*, :file "cljs/core.cljs", :end-column 7, :column 1, :dynamic true, :line 56, :end-line 60, :tag any, :doc "Var bound to the current namespace. Only used for bootstrapping.", :jsdoc ["@type {*}"]}, *assert* {:name cljs.core/*assert*, :file "cljs/core.cljs", :line 67, :column 1, :end-line 69, :end-column 11, :dynamic true, :meta {:file "cljs/core.cljs", :line 69, :column 3, :end-line 69, :end-column 11, :dynamic true}, :tag any}, create-tree-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8245, :column 8, :end-line 8245, :end-column 27, :private true, :arglists (quote ([tree ascending? cnt]))}, :private true, :name cljs.core/create-tree-map-seq, :file "cljs/core.cljs", :end-column 27, :method-params ([tree ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8245, :ret-tag cljs.core/PersistentTreeMapSeq, :end-line 8245, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tree ascending? cnt]))}, ICollection {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 25, :column 14, :line 594, :protocol-info {:methods {-conj [[coll o]]}}, :end-line 594, :sigs {:-conj {:name -conj, :arglists ([coll o]), :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)"}}, :doc "Protocol for adding to a collection.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ICollection, :file "cljs/core.cljs", :end-column 25, :column 1, :line 594, :protocol-info {:methods {-conj [[coll o]]}}, :info nil, :end-line 594, :tag any, :sigs {:-conj {:name -conj, :arglists ([coll o]), :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)"}}, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/Cycle cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/Repeat cljs.core/RSeq cljs.core/Iterate cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding to a collection.", :jsdoc ("@interface")}, chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2834, :column 7, :end-line 2834, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/chars, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2834, :end-line 2834, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2972, :column 7, :end-line 2972, :end-column 10, :arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [x]], :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}}, :name cljs.core/str, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [[] [x]], :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}, :method-params [[] [x]], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? false, :tag string} {:fixed-arity 1, :variadic? false, :tag #{any string}} {:fixed-arity 1, :variadic? true, :tag any}], :line 2972, :end-line 2972, :max-fixed-arity 1, :fn-var true, :arglists ([] [x] [x & ys]), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."}, next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1277, :column 12, :end-line 1277, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, :name cljs.core/next, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1277, :ret-tag seq, :end-line 1277, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, ASeq {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 18, :column 14, :line 611, :protocol-info {:methods {}}, :end-line 611, :sigs {}, :doc "Marker protocol indicating an array sequence.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ASeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 611, :protocol-info {:methods {}}, :info nil, :end-line 611, :tag any, :sigs {}, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/List cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Marker protocol indicating an array sequence.", :jsdoc ("@interface")}, pr-seq-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10208, :column 7, :end-line 10208, :end-column 20, :arglists (quote ([objs writer opts]))}, :name cljs.core/pr-seq-writer, :file "cljs/core.cljs", :end-column 20, :method-params ([objs writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10208, :ret-tag clj-nil, :end-line 10208, :max-fixed-arity 3, :fn-var true, :arglists (quote ([objs writer opts]))}, SeqIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/SeqIter, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 4050, :record false, :end-line 4050, :tag function, :skip-protocol-flag nil}, IFn {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 17, :column 14, :line 550, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :end-line 550, :sigs {:-invoke {:name -invoke, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :doc nil}}, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IFn, :file "cljs/core.cljs", :end-column 17, :column 1, :line 550, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :info nil, :end-line 550, :tag any, :sigs {:-invoke {:name -invoke, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :doc nil}}, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/Keyword cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/Var cljs.core/TransientHashMap cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Symbol cljs.core/MetaFn cljs.core/RedNode}, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :jsdoc ("@interface")}, regexp? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9982, :column 7, :end-line 9982, :end-column 14, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, :name cljs.core/regexp?, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 9982, :ret-tag boolean, :end-line 9982, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8901, :column 7, :end-line 8901, :end-column 15, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/hash-map, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag clj}], :line 8901, :ret-tag any, :end-line 8901, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new hash map with supplied mappings."}, *exec-tap-fn* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 79, :column 3, :end-line 79, :end-column 16, :doc "Arranges to have tap functions executed via the supplied f, a\n  function of no arguments. Returns true if successful, false otherwise.", :dynamic true, :arglists (quote ([f]))}, :name cljs.core/*exec-tap-fn*, :file "cljs/core.cljs", :end-column 16, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :dynamic true, :line 77, :ret-tag #{boolean js}, :end-line 79, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Arranges to have tap functions executed via the supplied f, a\n  function of no arguments. Returns true if successful, false otherwise."}, underive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10958, :column 7, :end-line 10958, :end-column 15, :arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[tag parent] [h tag parent]], :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/underive, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[tag parent] [h tag parent]], :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params [[tag parent] [h tag parent]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag clj-nil} {:fixed-arity 3, :variadic? false, :tag #{nil any}}], :line 10958, :end-line 10958, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, array-copy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2209, :column 8, :end-line 2209, :end-column 18, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy, :file "cljs/core.cljs", :end-column 18, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2209, :end-line 2209, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, obj-map-compare-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6380, :column 8, :end-line 6380, :end-column 28, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/obj-map-compare-keys, :file "cljs/core.cljs", :end-column 28, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6380, :ret-tag number, :end-line 6380, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -reset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 864, :column 4, :end-line 864, :end-column 11, :protocol cljs.core/IReset, :doc "Sets the value of o to new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IReset, :name cljs.core/-reset!, :file "cljs/core.cljs", :end-column 11, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 862, :ret-tag any, :end-line 864, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of o to new-value."}, -rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 618, :column 9, :end-line 618, :end-column 14, :tag clj, :protocol cljs.core/ISeq, :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-rest, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 614, :ret-tag clj, :end-line 618, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()"}, nil-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4016, :column 7, :end-line 4016, :end-column 15, :arglists (quote ([]))}, :name cljs.core/nil-iter, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4016, :ret-tag cljs.core/t_cljs$core11293, :end-line 4016, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10199, :column 8, :end-line 10199, :end-column 17, :private true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, :private true, :name cljs.core/pr-writer, :file "cljs/core.cljs", :end-column 17, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10199, :ret-tag #{any clj-nil}, :end-line 10199, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, false? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2229, :column 16, :end-line 2229, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, :name cljs.core/false?, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2229, :ret-tag boolean, :end-line 2229, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, RangedIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/RangedIterator, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 5457, :record false, :end-line 5457, :tag function, :skip-protocol-flag nil}, *print-readably* {:meta {:file "cljs/core.cljs", :line 120, :column 3, :end-line 120, :end-column 19, :dynamic true, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, :name cljs.core/*print-readably*, :file "cljs/core.cljs", :end-column 19, :column 1, :dynamic true, :line 114, :end-line 120, :tag any, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, ints {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2836, :column 7, :end-line 2836, :end-column 11, :arglists (quote ([x]))}, :name cljs.core/ints, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2836, :end-line 2836, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, some-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4671, :column 7, :end-line 4671, :end-column 14, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[p] [p1 p2] [p1 p2 p3]], :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/some-fn, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[p] [p1 p2] [p1 p2 p3]], :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params [[p] [p1 p2] [p1 p2 p3]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag function} {:fixed-arity 3, :variadic? false, :tag function} {:fixed-arity 3, :variadic? true, :tag function}], :line 4671, :end-line 4671, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates."}, demunge-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11485, :column 8, :end-line 11485, :end-column 23, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/demunge-pattern, :file "cljs/core.cljs", :end-column 23, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11485, :ret-tag clj-nil, :end-line 11485, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, maybe-enable-print! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11710, :column 8, :end-line 11710, :end-column 27, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/maybe-enable-print!, :file "cljs/core.cljs", :end-column 27, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11710, :ret-tag #{any clj-nil}, :end-line 11710, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *flush-on-newline* {:meta {:file "cljs/core.cljs", :line 105, :column 3, :end-line 105, :end-column 21, :dynamic true, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, :name cljs.core/*flush-on-newline*, :file "cljs/core.cljs", :end-column 21, :column 1, :dynamic true, :line 100, :end-line 105, :tag any, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, to-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3658, :column 7, :end-line 3658, :end-column 15, :arglists (quote ([coll])), :doc "Returns an array containing the contents of coll."}, :name cljs.core/to-array, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3658, :ret-tag array, :end-line 3658, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an array containing the contents of coll."}, build-subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5977, :column 8, :end-line 5977, :end-column 20, :private true, :arglists (quote ([meta v start end __hash]))}, :private true, :name cljs.core/build-subvec, :file "cljs/core.cljs", :end-column 20, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5977, :ret-tag cljs.core/Subvec, :end-line 5977, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash]))}, maybe-warn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 453, :column 8, :end-line 453, :end-column 18, :private true, :arglists (quote ([e]))}, :private true, :name cljs.core/maybe-warn, :file "cljs/core.cljs", :end-column 18, :method-params ([e]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 453, :ret-tag #{any clj-nil}, :end-line 453, :max-fixed-arity 1, :fn-var true, :arglists (quote ([e]))}, Namespace {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/Namespace, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 11589, :record false, :end-line 11589, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}}, list? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3122, :column 7, :end-line 3122, :end-column 12, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, :name cljs.core/list?, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3122, :ret-tag boolean, :end-line 3122, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, tree-map-remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8713, :column 8, :end-line 8713, :end-column 23, :private true, :arglists (quote ([comp tree k found]))}, :private true, :name cljs.core/tree-map-remove, :file "cljs/core.cljs", :end-column 23, :method-params ([comp tree k found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 8713, :ret-tag #{nil clj clj-nil}, :end-line 8713, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k found]))}, PersistentQueueIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/PersistentQueueIter, :file "cljs/core.cljs", :end-column 29, :type true, :column 10, :line 6191, :record false, :end-line 6191, :tag function, :skip-protocol-flag nil}, HashCollisionNode {:num-fields 4, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/HashCollisionNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7589, :record false, :end-line 7589, :tag function, :skip-protocol-flag #{cljs.core/IIterable}}, array? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 240, :column 16, :end-line 240, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, :name cljs.core/array?, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 240, :ret-tag boolean, :end-line 240, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, prefers* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10984, :column 8, :end-line 10984, :end-column 16, :private true, :arglists (quote ([x y prefer-table]))}, :private true, :name cljs.core/prefers*, :file "cljs/core.cljs", :end-column 16, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10984, :ret-tag #{boolean clj-nil}, :end-line 10984, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table]))}, simple-ident? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3380, :column 7, :end-line 3380, :end-column 20, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword without a namespace"}, :name cljs.core/simple-ident?, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3380, :ret-tag boolean, :end-line 3380, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword without a namespace"}, clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1214, :column 7, :end-line 1214, :end-column 12, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, :name cljs.core/clone, :file "cljs/core.cljs", :end-column 12, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1214, :ret-tag clj, :end-line 1214, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, scan-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6366, :column 8, :end-line 6366, :end-column 18, :private true, :arglists (quote ([incr k array]))}, :private true, :name cljs.core/scan-array, :file "cljs/core.cljs", :end-column 18, :method-params ([incr k array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6366, :ret-tag #{number clj-nil}, :end-line 6366, :max-fixed-arity 3, :fn-var true, :arglists (quote ([incr k array]))}, demunge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11540, :column 7, :end-line 11540, :end-column 14, :arglists (quote ([name]))}, :name cljs.core/demunge, :file "cljs/core.cljs", :end-column 14, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11540, :ret-tag any, :end-line 11540, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, bit-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2897, :column 7, :end-line 2897, :end-column 14, :arglists (quote ([x])), :doc "Bitwise complement"}, :name cljs.core/bit-not, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2897, :ret-tag number, :end-line 2897, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Bitwise complement"}, quote-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10093, :column 17, :end-line 10093, :end-column 29, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/quote-string, :file "cljs/core.cljs", :end-column 29, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10093, :ret-tag string, :end-line 10093, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2711, :column 15, :end-line 2711, :end-column 19, :tag number, :arglists (quote ([x]))}, :name cljs.core/byte, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2711, :ret-tag number, :end-line 2711, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, max {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2697, :column 15, :end-line 2697, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false} {:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 2, :variadic? true, :tag #{nil any}}], :line 2697, :ret-tag number, :end-line 2697, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the greatest of the nums."}, ->Repeat {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 16, :column 10, :factory :positional, :line 4920, :end-line 4920, :arglists (quote ([meta count val next __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Repeat."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Repeat, :file "cljs/core.cljs", :end-column 16, :method-params ([meta count val next __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 4920, :ret-tag cljs.core/Repeat, :end-line 4920, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count val next __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/Repeat."}, IComparable {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 25, :column 14, :line 829, :protocol-info {:methods {-compare [[x y]]}}, :end-line 829, :sigs {:-compare {:name -compare, :arglists ([x y]), :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y."}}, :doc "Protocol for values that can be compared.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IComparable, :file "cljs/core.cljs", :end-column 25, :column 1, :line 829, :protocol-info {:methods {-compare [[x y]]}}, :info nil, :end-line 829, :tag any, :sigs {:-compare {:name -compare, :arglists ([x y]), :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y."}}, :impls #{js/Date cljs.core/Keyword cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/Symbol cljs.core/UUID cljs.core/RedNode}, :doc "Protocol for values that can be compared.", :jsdoc ("@interface")}, == {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2934, :column 16, :end-line 2934, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/==, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [x y]], :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params [[x] [x y]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? false, :tag boolean} {:fixed-arity 2, :variadic? true, :tag boolean}], :line 2934, :ret-tag boolean, :end-line 2934, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined."}, ->t_cljs$core9711 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta9712])), :doc "Positional factory function for cljs.core/t_cljs$core9711.", :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t_cljs$core9711, :file "cljs/core.cljs", :method-params ([meta9712]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :variadic? false, :factory :positional, :line 4017, :ret-tag cljs.core/t_cljs$core9711, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta9712])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :doc "Positional factory function for cljs.core/t_cljs$core9711."}, parents {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10899, :column 7, :end-line 10899, :end-column 14, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tag] [h tag]], :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/parents, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[tag] [h tag]], :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params [[tag] [h tag]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag #{nil clj-nil}}], :line 10899, :end-line 10899, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1828, :column 7, :end-line 1828, :end-column 12, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, :name cljs.core/count, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1828, :ret-tag number, :end-line 1828, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, -disjoin! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 826, :column 9, :end-line 826, :end-column 18, :tag clj, :protocol cljs.core/ITransientSet, :doc "Returns tcoll without v.", :arglists (quote ([tcoll v]))}, :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 824, :ret-tag clj, :end-line 826, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll v])), :doc "Returns tcoll without v."}, *loaded-libs* {:meta {:file "cljs/core.cljs", :line 180, :column 3, :end-line 180, :end-column 16, :dynamic true, :jsdoc ["@type {*}"]}, :name cljs.core/*loaded-libs*, :file "cljs/core.cljs", :end-column 16, :column 1, :dynamic true, :line 177, :end-line 180, :tag any, :jsdoc ["@type {*}"]}, EMPTY {:name cljs.core/EMPTY, :file "cljs/core.cljs", :line 4124, :column 1, :end-line 4124, :end-column 21, :private true, :meta {:file "cljs/core.cljs", :line 4124, :column 16, :end-line 4124, :end-column 21, :private true}, :tag cljs.core/Empty}, ->TransientHashMap {:protocol-inline nil, :meta {:protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 26, :column 10, :factory :positional, :line 8050, :end-line 8050, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TransientHashMap."}, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientHashMap, :file "cljs/core.cljs", :end-column 26, :method-params ([edit root count has-nil? nil-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 8050, :ret-tag cljs.core/TransientHashMap, :end-line 8050, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TransientHashMap."}, array-index-of-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6590, :column 8, :end-line 6590, :end-column 30, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-symbol?, :file "cljs/core.cljs", :end-column 30, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 6590, :ret-tag number, :end-line 6590, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ArrayChunk {:meta {:file "cljs/core.cljs", :line 3510, :column 10, :end-line 3510, :end-column 20, :declared true}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/ArrayChunk, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3529, :record false, :declared true, :end-line 3529, :tag function, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, sorted-map-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8941, :column 7, :end-line 8941, :end-column 20, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map-by, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}, :method-params [(comparator keyvals)], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? true, :tag any}], :line 8941, :ret-tag any, :end-line 8941, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator."}, apply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3939, :column 7, :end-line 3939, :end-column 12, :arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :top-fn {:variadic? true, :fixed-arity 5, :max-fixed-arity 5, :method-params [[f args] [f x args] [f x y args] [f x y z args]], :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/apply, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? true, :fixed-arity 5, :max-fixed-arity 5, :method-params [[f args] [f x args] [f x y args] [f x y z args]], :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}, :method-params [[f args] [f x args] [f x y args] [f x y z args]], :protocol-impl nil, :fixed-arity 5, :arglists-meta (nil nil nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag any} {:fixed-arity 4, :variadic? false, :tag any} {:fixed-arity 5, :variadic? false, :tag any} {:fixed-arity 5, :variadic? true, :tag any}], :line 3939, :end-line 3939, :max-fixed-arity 5, :fn-var true, :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args."}, get-global-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10871, :column 8, :end-line 10871, :end-column 28, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/get-global-hierarchy, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10871, :ret-tag clj-nil, :end-line 10871, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, add-to-string-hash-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 983, :column 7, :end-line 983, :end-column 31, :arglists (quote ([k]))}, :name cljs.core/add-to-string-hash-cache, :file "cljs/core.cljs", :end-column 31, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 983, :ret-tag number, :end-line 983, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10736, :column 7, :end-line 10736, :end-column 14, :arglists (quote ([x & {:keys [keyword-fn], :or {keyword-fn name}, :as options}])), :doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by `key->js`.\n  Options is a key-value pair, where the only valid key is\n  :keyword-fn, which should point to a single-argument function to be\n  called on keyword keys. Default to `name`.", :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(x {:keys [keyword-fn], :or {keyword-fn name}, :as options})], :arglists ([x & {:keys [keyword-fn], :or {keyword-fn name}, :as options}]), :arglists-meta (nil)}}, :name cljs.core/clj->js, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic? true, :fixed-arity 1, :max-fixed-arity 1, :method-params [(x {:keys [keyword-fn], :or {keyword-fn name}, :as options})], :arglists ([x & {:keys [keyword-fn], :or {keyword-fn name}, :as options}]), :arglists-meta (nil)}, :method-params [(x {:keys [keyword-fn], :or {keyword-fn name}, :as options})], :protocol-impl nil, :fixed-arity 1, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? true}], :line 10736, :ret-tag any, :end-line 10736, :max-fixed-arity 1, :fn-var true, :arglists ([x & {:keys [keyword-fn], :or {keyword-fn name}, :as options}]), :doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by `key->js`.\n  Options is a key-value pair, where the only valid key is\n  :keyword-fn, which should point to a single-argument function to be\n  called on keyword keys. Default to `name`."}, TransientArrayMap {:meta {:file "cljs/core.cljs", :line 6647, :column 10, :end-line 6647, :end-column 27, :declared true}, :num-fields 3, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientArrayMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7052, :record false, :declared true, :end-line 7052, :tag function, :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->TransientVector {:protocol-inline nil, :meta {:protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 25, :column 10, :factory :positional, :line 6056, :end-line 6056, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TransientVector."}, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientVector, :file "cljs/core.cljs", :end-column 25, :method-params ([cnt shift root tail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6056, :ret-tag cljs.core/TransientVector, :end-line 6056, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :doc "Positional factory function for cljs.core/TransientVector."}, IChunkedNext {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 26, :column 14, :line 847, :protocol-info {:methods {-chunked-next [[coll]]}}, :end-line 847, :sigs {:-chunked-next {:name -chunked-next, :arglists ([coll]), :doc "Returns a new collection of coll without the first chunk."}}, :doc "Protocol for accessing the chunks of a collection.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IChunkedNext, :file "cljs/core.cljs", :end-column 26, :column 1, :line 847, :protocol-info {:methods {-chunked-next [[coll]]}}, :info nil, :end-line 847, :tag any, :sigs {:-chunked-next {:name -chunked-next, :arglists ([coll]), :doc "Returns a new collection of coll without the first chunk."}}, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/Range}, :doc "Protocol for accessing the chunks of a collection.", :jsdoc ("@interface")}, interpose {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5118, :column 7, :end-line 5118, :end-column 16, :arglists (quote ([sep] [sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[sep] [sep coll]], :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}}, :name cljs.core/interpose, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[sep] [sep coll]], :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}, :method-params [[sep] [sep coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 5118, :end-line 5118, :max-fixed-arity 2, :fn-var true, :arglists ([sep] [sep coll]), :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided."}, TransformerIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/TransformerIterator, :file "cljs/core.cljs", :end-column 29, :type true, :column 10, :line 4153, :record false, :end-line 4153, :tag function, :skip-protocol-flag nil}, ->BlackNode {:protocol-inline nil, :meta {:protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 19, :column 10, :factory :positional, :line 8348, :end-line 8348, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/BlackNode."}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->BlackNode, :file "cljs/core.cljs", :end-column 19, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 8348, :ret-tag cljs.core/BlackNode, :end-line 8348, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/BlackNode."}, deref {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1469, :column 7, :end-line 1469, :end-column 12, :arglists (quote ([o])), :doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?."}, :name cljs.core/deref, :file "cljs/core.cljs", :end-column 12, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1469, :ret-tag any, :end-line 1469, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?."}, pv-aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5365, :column 8, :end-line 5365, :end-column 15, :private true, :arglists (quote ([node idx]))}, :private true, :name cljs.core/pv-aget, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 5365, :ret-tag any, :end-line 5365, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node idx]))}, assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1993, :column 7, :end-line 1993, :end-column 12, :arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index. Note - index must be <= (count vector).", :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll k v]], :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic? true, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll k v]], :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}, :method-params [[coll k v]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 3, :variadic? false, :tag #{clj any}} {:fixed-arity 3, :variadic? true, :tag #{clj any}}], :line 1993, :end-line 1993, :max-fixed-arity 3, :fn-var true, :arglists ([coll k v] [coll k v & kvs]), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index. Note - index must be <= (count vector)."}, transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3826, :column 7, :end-line 3826, :end-column 16, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, :name cljs.core/transient, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3826, :ret-tag clj, :end-line 3826, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, -disjoin {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 666, :column 9, :end-line 666, :end-column 17, :tag clj, :protocol cljs.core/ISet, :doc "Returns a new collection of coll that does not contain v.", :arglists (quote ([coll v]))}, :protocol cljs.core/ISet, :name cljs.core/-disjoin, :file "cljs/core.cljs", :end-column 17, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 664, :ret-tag clj, :end-line 666, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll v])), :doc "Returns a new collection of coll that does not contain v."}, chunk-cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3634, :column 7, :end-line 3634, :end-column 17, :arglists (quote ([chunk rest]))}, :name cljs.core/chunk-cons, :file "cljs/core.cljs", :end-column 17, :method-params ([chunk rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3634, :ret-tag #{nil cljs.core/ChunkedCons}, :end-line 3634, :max-fixed-arity 2, :fn-var true, :arglists (quote ([chunk rest]))}, ArrayIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/ArrayIter, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 4035, :record false, :end-line 4035, :tag function, :skip-protocol-flag nil}, comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11390, :column 7, :end-line 11390, :end-column 17, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, :name cljs.core/comparator, :file "cljs/core.cljs", :end-column 17, :method-params ([pred]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 11390, :ret-tag function, :end-line 11390, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, print-prefix-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10323, :column 7, :end-line 10323, :end-column 23, :arglists (quote ([prefix m print-one writer opts]))}, :name cljs.core/print-prefix-map, :file "cljs/core.cljs", :end-column 23, :method-params ([prefix m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10323, :ret-tag any, :end-line 10323, :max-fixed-arity 5, :fn-var true, :arglists (quote ([prefix m print-one writer opts]))}, sorted-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8932, :column 7, :end-line 8932, :end-column 17, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag any}], :line 8932, :ret-tag any, :end-line 8932, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings."}, drop-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4823, :column 7, :end-line 4823, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred coll]], :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop-while, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[pred] [pred coll]], :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params [[pred] [pred coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag function} {:fixed-arity 2, :variadic? false, :tag cljs.core/LazySeq}], :line 4823, :end-line 4823, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided."}, IWriter {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 21, :column 14, :line 763, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :end-line 763, :sigs {:-write {:name -write, :arglists ([writer s]), :doc "Writes s with writer and returns the result."}, :-flush {:name -flush, :arglists ([writer]), :doc "Flush writer."}}, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IWriter, :file "cljs/core.cljs", :end-column 21, :column 1, :line 763, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :info nil, :end-line 763, :tag any, :sigs {:-write {:name -write, :arglists ([writer s]), :doc "Writes s with writer and returns the result."}, :-flush {:name -flush, :arglists ([writer]), :doc "Flush writer."}}, :impls #{cljs.core/StringBufferWriter}, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :jsdoc ("@interface")}, KeySeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/KeySeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 8951, :record false, :end-line 8951, :tag function, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10597, :column 16, :end-line 10597, :end-column 25, :tag boolean, :arglists (quote ([x])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, :name cljs.core/realized?, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10597, :ret-tag boolean, :end-line 10597, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, *print-fn* {:meta {:file "cljs/core.cljs", :line 75, :column 3, :end-line 75, :end-column 13, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :dynamic true}, :name cljs.core/*print-fn*, :file "cljs/core.cljs", :end-column 13, :column 1, :dynamic true, :line 71, :end-line 75, :tag any, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2391, :column 15, :end-line 2391, :end-column 22, :tag number, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, :name cljs.core/compare, :file "cljs/core.cljs", :end-column 22, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2391, :ret-tag number, :end-line 2391, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, complement {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4272, :column 7, :end-line 4272, :end-column 17, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, :name cljs.core/complement, :file "cljs/core.cljs", :end-column 17, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4272, :ret-tag function, :end-line 4272, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, lookup-sentinel {:name cljs.core/lookup-sentinel, :file "cljs/core.cljs", :line 2227, :column 1, :end-line 2227, :end-column 31, :private true, :meta {:file "cljs/core.cljs", :line 2227, :column 16, :end-line 2227, :end-column 31, :private true}, :tag object}, -assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 808, :column 9, :end-line 808, :end-column 16, :tag clj, :protocol cljs.core/ITransientAssociative, :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists (quote ([tcoll key val]))}, :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :file "cljs/core.cljs", :end-column 16, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 806, :ret-tag clj, :end-line 808, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll key val])), :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."}, *print-dup* {:meta {:file "cljs/core.cljs", :line 136, :column 3, :end-line 136, :end-column 14, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, :name cljs.core/*print-dup*, :file "cljs/core.cljs", :end-column 14, :column 1, :dynamic true, :line 130, :end-line 136, :tag any, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, string-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4032, :column 7, :end-line 4032, :end-column 18, :arglists (quote ([x]))}, :name cljs.core/string-iter, :file "cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4032, :ret-tag cljs.core/StringIter, :end-line 4032, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10720, :column 4, :end-line 10720, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-key->js, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10718, :ret-tag any, :end-line 10720, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}, IDeref {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 20, :column 14, :line 684, :protocol-info {:methods {-deref [[o]]}}, :end-line 684, :sigs {:-deref {:name -deref, :arglists ([o]), :doc "Returns the value of the reference o."}}, :doc "Protocol for adding dereference functionality to a reference.", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IDeref, :file "cljs/core.cljs", :end-column 20, :column 1, :line 684, :protocol-info {:methods {-deref [[o]]}}, :info nil, :end-line 684, :tag any, :sigs {:-deref {:name -deref, :arglists ([o]), :doc "Returns the value of the reference o."}}, :impls #{cljs.core/Reduced cljs.core/Volatile cljs.core/Delay cljs.core/Var cljs.core/Atom}, :doc "Protocol for adding dereference functionality to a reference.", :jsdoc ("@interface")}, sequence {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4212, :column 7, :end-line 4212, :end-column 15, :arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [xform coll]], :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}}, :name cljs.core/sequence, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[coll] [xform coll]], :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}, :method-params [[coll] [xform coll]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag #{seq cljs.core/IList}} {:fixed-arity 2, :variadic? false, :tag clj} {:fixed-arity 2, :variadic? true, :tag clj}], :line 4212, :end-line 4212, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [xform coll] [xform coll & colls]), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments"}, constantly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4282, :column 7, :end-line 4282, :end-column 17, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, :name cljs.core/constantly, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4282, :ret-tag function, :end-line 4282, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, ->RangedIterator {:protocol-inline nil, :meta {:protocols #{cljs.core/Object}, :file "cljs/core.cljs", :end-column 24, :column 10, :factory :positional, :line 5457, :end-line 5457, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/RangedIterator."}, :protocols #{cljs.core/Object}, :name cljs.core/->RangedIterator, :file "cljs/core.cljs", :end-column 24, :method-params ([i base arr v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 5457, :ret-tag cljs.core/RangedIterator, :end-line 5457, :max-fixed-arity 6, :fn-var true, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil, :doc "Positional factory function for cljs.core/RangedIterator."}, chunked-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5832, :column 7, :end-line 5832, :end-column 18, :arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[vec i off] [vec node i off] [vec node i off meta]], :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}}, :name cljs.core/chunked-seq, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic? false, :fixed-arity 5, :max-fixed-arity 5, :method-params [[vec i off] [vec node i off] [vec node i off meta]], :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}, :method-params [[vec i off] [vec node i off] [vec node i off meta]], :protocol-impl nil, :fixed-arity 5, :arglists-meta (nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 3, :variadic? false, :tag cljs.core/ChunkedSeq} {:fixed-arity 4, :variadic? false, :tag cljs.core/ChunkedSeq} {:fixed-arity 5, :variadic? false, :tag cljs.core/ChunkedSeq}], :line 5832, :end-line 5832, :max-fixed-arity 5, :fn-var true, :arglists ([vec i off] [vec node i off] [vec node i off meta])}, ISorted {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 21, :column 14, :line 746, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :end-line 746, :sigs {:-sorted-seq {:name -sorted-seq, :arglists ([coll ascending?]), :doc "Returns a sorted seq from coll in either ascending or descending order."}, :-sorted-seq-from {:name -sorted-seq-from, :arglists ([coll k ascending?]), :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)"}, :-entry-key {:name -entry-key, :arglists ([coll entry]), :doc "Returns the key for entry."}, :-comparator {:name -comparator, :arglists ([coll]), :doc "Returns the comparator for coll."}}, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/ISorted, :file "cljs/core.cljs", :end-column 21, :column 1, :line 746, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :info nil, :end-line 746, :tag any, :sigs {:-sorted-seq {:name -sorted-seq, :arglists ([coll ascending?]), :doc "Returns a sorted seq from coll in either ascending or descending order."}, :-sorted-seq-from {:name -sorted-seq-from, :arglists ([coll k ascending?]), :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)"}, :-entry-key {:name -entry-key, :arglists ([coll entry]), :doc "Returns the key for entry."}, :-comparator {:name -comparator, :arglists ([coll]), :doc "Returns the comparator for coll."}}, :impls #{cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :jsdoc ("@interface")}, make-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 416, :column 14, :end-line 416, :end-column 24, :tag array, :arglists (quote ([size] [type size] [type size & more-sizes])), :doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size] [type size]], :arglists ([size] [type size] [type size & more-sizes]), :arglists-meta (nil nil nil)}}, :name cljs.core/make-array, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[size] [type size]], :arglists ([size] [type size] [type size & more-sizes]), :arglists-meta (nil nil nil)}, :method-params [[size] [type size]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 1, :variadic? false, :tag array} {:fixed-arity 2, :variadic? false, :tag array} {:fixed-arity 2, :variadic? true, :tag array}], :line 416, :ret-tag array, :end-line 416, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([size] [type size] [type size & more-sizes]), :doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments."}, checked-aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 458, :column 8, :end-line 458, :end-column 20, :private true, :arglists (quote ([array idx] [array idx & idxs])), :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[array idx]], :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/checked-aget, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? true, :fixed-arity 2, :max-fixed-arity 2, :method-params [[array idx]], :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}, :method-params [[array idx]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? true, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 2, :variadic? true, :tag any}], :line 458, :end-line 458, :max-fixed-arity 2, :fn-var true, :arglists ([array idx] [array idx & idxs])}, shorts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2835, :column 7, :end-line 2835, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/shorts, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2835, :end-line 2835, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, *unchecked-if* {:name cljs.core/*unchecked-if*, :file "cljs/core.cljs", :line 26, :column 1, :end-line 26, :end-column 20, :meta {:file "cljs/core.cljs", :line 26, :column 6, :end-line 26, :end-column 20}, :tag boolean}, ->RSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 14, :column 10, :factory :positional, :line 1692, :end-line 1692, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/RSeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->RSeq, :file "cljs/core.cljs", :end-column 14, :method-params ([ci i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 1692, :ret-tag cljs.core/RSeq, :end-line 1692, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/RSeq."}, enable-console-print! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 191, :column 7, :end-line 191, :end-column 28, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, :name cljs.core/enable-console-print!, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 191, :ret-tag clj-nil, :end-line 191, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, -flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 767, :column 4, :end-line 767, :end-column 10, :protocol cljs.core/IWriter, :doc "Flush writer.", :arglists (quote ([writer]))}, :protocol cljs.core/IWriter, :name cljs.core/-flush, :file "cljs/core.cljs", :end-column 10, :method-params ([writer]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 763, :ret-tag any, :end-line 767, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer])), :doc "Flush writer."}, -lastIndexOf {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1559, :column 8, :end-line 1559, :end-column 20, :private true, :arglists (quote ([coll x] [coll x start])), :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll x] [coll x start]], :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/-lastIndexOf, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[coll x] [coll x start]], :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}, :method-params [[coll x] [coll x start]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag #{any number}}], :line 1559, :end-line 1559, :max-fixed-arity 3, :fn-var true, :arglists ([coll x] [coll x start])}, completing {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2585, :column 7, :end-line 2585, :end-column 17, :arglists (quote ([f] [f cf])), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f cf]], :arglists ([f] [f cf]), :arglists-meta (nil nil)}}, :name cljs.core/completing, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[f] [f cf]], :arglists ([f] [f cf]), :arglists-meta (nil nil)}, :method-params [[f] [f cf]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag function}], :line 2585, :end-line 2585, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f cf]), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument."}, unchecked-negate-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2785, :column 7, :end-line 2785, :end-column 27, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate-int, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2785, :ret-tag number, :end-line 2785, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->PersistentVector {:protocol-inline nil, :meta {:protocols #{cljs.core/APersistentVector cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 26, :column 10, :factory :positional, :line 5498, :end-line 5498, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/PersistentVector."}, :protocols #{cljs.core/APersistentVector cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentVector, :file "cljs/core.cljs", :end-column 26, :method-params ([meta cnt shift root tail __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 5498, :ret-tag cljs.core/PersistentVector, :end-line 5498, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :doc "Positional factory function for cljs.core/PersistentVector."}, equiv-sequential {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2994, :column 8, :end-line 2994, :end-column 24, :private true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, :private true, :name cljs.core/equiv-sequential, :file "cljs/core.cljs", :end-column 24, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2994, :ret-tag boolean, :end-line 2994, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, hash-unordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1365, :column 15, :end-line 1365, :end-column 34, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-unordered-coll, :file "cljs/core.cljs", :end-column 34, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1365, :ret-tag number, :end-line 1365, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, repeat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5017, :column 7, :end-line 5017, :end-column 13, :arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [n x]], :arglists ([x] [n x]), :arglists-meta (nil nil)}}, :name cljs.core/repeat, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[x] [n x]], :arglists ([x] [n x]), :arglists-meta (nil nil)}, :method-params [[x] [n x]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag cljs.core/Repeat} {:fixed-arity 2, :variadic? false, :tag #{any cljs.core/Repeat}}], :line 5017, :end-line 5017, :max-fixed-arity 2, :fn-var true, :arglists ([x] [n x]), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs."}, unchecked-inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2762, :column 7, :end-line 2762, :end-column 20, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2762, :ret-tag number, :end-line 2762, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, nthnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2962, :column 7, :end-line 2962, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, :name cljs.core/nthnext, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2962, :ret-tag seq, :end-line 2962, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, preserving-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10602, :column 8, :end-line 10602, :end-column 26, :private true, :arglists (quote ([rf]))}, :private true, :name cljs.core/preserving-reduced, :file "cljs/core.cljs", :end-column 26, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 10602, :ret-tag function, :end-line 10602, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf]))}, get-validator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4569, :column 7, :end-line 4569, :end-column 20, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, :name cljs.core/get-validator, :file "cljs/core.cljs", :end-column 20, :method-params ([iref]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4569, :ret-tag any, :end-line 4569, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, StringIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/StringIter, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 4023, :record false, :end-line 4023, :tag function, :skip-protocol-flag nil}, number? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 247, :column 16, :end-line 247, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript number."}, :name cljs.core/number?, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 247, :ret-tag boolean, :end-line 247, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript number."}, -conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 801, :column 9, :end-line 801, :end-column 15, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Adds value val to tcoll and returns tcoll.", :arglists (quote ([tcoll val]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :file "cljs/core.cljs", :end-column 15, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 799, :ret-tag clj, :end-line 801, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll val])), :doc "Adds value val to tcoll and returns tcoll."}, ->PersistentArrayMapSeq {:protocol-inline nil, :meta {:protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :file "cljs/core.cljs", :end-column 31, :column 10, :factory :positional, :line 6749, :end-line 6749, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/PersistentArrayMapSeq."}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentArrayMapSeq, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6749, :ret-tag cljs.core/PersistentArrayMapSeq, :end-line 6749, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :doc "Positional factory function for cljs.core/PersistentArrayMapSeq."}, chunk-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3651, :column 7, :end-line 3651, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-next, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3651, :ret-tag #{seq any}, :end-line 3651, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, ArrayList {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ArrayList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 9556, :record false, :end-line 9556, :tag function, :skip-protocol-flag nil}, print-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10277, :column 7, :end-line 10277, :end-column 16, :arglists (quote ([& objs])), :doc "print to a string, returning it", :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/print-str, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic? true, :fixed-arity 0, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :fixed-arity 0, :arglists-meta (nil), :column 1, :variadic? true, :methods [{:fixed-arity 0, :variadic? true, :tag string}], :line 10277, :ret-tag any, :end-line 10277, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "print to a string, returning it"}, not-any? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4257, :column 7, :end-line 4257, :end-column 15, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, :name cljs.core/not-any?, :file "cljs/core.cljs", :end-column 15, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4257, :ret-tag boolean, :end-line 4257, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, into-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 524, :column 14, :end-line 524, :end-column 24, :tag array, :arglists (quote ([aseq] [type aseq])), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[aseq] [type aseq]], :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}}, :name cljs.core/into-array, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic? false, :fixed-arity 2, :max-fixed-arity 2, :method-params [[aseq] [type aseq]], :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}, :method-params [[aseq] [type aseq]], :protocol-impl nil, :fixed-arity 2, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag array} {:fixed-arity 2, :variadic? false, :tag #{nil any}}], :line 524, :ret-tag array, :end-line 524, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([aseq] [type aseq]), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure."}, -hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 724, :column 4, :end-line 724, :end-column 9, :protocol cljs.core/IHash, :doc "Returns the hash code of o.", :arglists (quote ([o]))}, :protocol cljs.core/IHash, :name cljs.core/-hash, :file "cljs/core.cljs", :end-column 9, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 722, :ret-tag any, :end-line 724, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of o."}, qualified-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3392, :column 7, :end-line 3392, :end-column 24, :arglists (quote ([x])), :doc "Return true if x is a symbol with a namespace"}, :name cljs.core/qualified-symbol?, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3392, :ret-tag boolean, :end-line 3392, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol with a namespace"}, -dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 814, :column 9, :end-line 814, :end-column 17, :tag clj, :protocol cljs.core/ITransientMap, :doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists (quote ([tcoll key]))}, :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :file "cljs/core.cljs", :end-column 17, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 812, :ret-tag clj, :end-line 814, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll key])), :doc "Returns a new transient collection of tcoll without the mapping for key."}, ->Reduced {:protocol-inline nil, :meta {:protocols #{cljs.core/IDeref}, :file "cljs/core.cljs", :end-column 17, :column 10, :factory :positional, :line 1443, :end-line 1443, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}, :doc "Positional factory function for cljs.core/Reduced."}, :protocols #{cljs.core/IDeref}, :name cljs.core/->Reduced, :file "cljs/core.cljs", :end-column 17, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 1443, :ret-tag cljs.core/Reduced, :end-line 1443, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}, :doc "Positional factory function for cljs.core/Reduced."}, chunk-buffer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3526, :column 7, :end-line 3526, :end-column 19, :arglists (quote ([capacity]))}, :name cljs.core/chunk-buffer, :file "cljs/core.cljs", :end-column 19, :method-params ([capacity]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 3526, :ret-tag cljs.core/ChunkBuffer, :end-line 3526, :max-fixed-arity 1, :fn-var true, :arglists (quote ([capacity]))}, seqable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2253, :column 7, :end-line 2253, :end-column 15, :arglists (quote ([s])), :doc "Return true if the seq function is supported for s"}, :name cljs.core/seqable?, :file "cljs/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2253, :ret-tag boolean, :end-line 2253, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return true if the seq function is supported for s"}, symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1049, :column 16, :end-line 1049, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, :name cljs.core/symbol?, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1049, :ret-tag boolean, :end-line 1049, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, m3-hash-unencoded-chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 949, :column 15, :end-line 949, :end-column 38, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-unencoded-chars, :file "cljs/core.cljs", :end-column 38, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 949, :ret-tag number, :end-line 949, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, unchecked-char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2726, :column 15, :end-line 2726, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-char, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2726, :ret-tag number, :end-line 2726, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, system-time {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 397, :column 7, :end-line 397, :end-column 18, :arglists (quote ([])), :doc "Returns highest resolution time offered by host in milliseconds."}, :name cljs.core/system-time, :file "cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 397, :ret-tag #{number js/Number}, :end-line 397, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns highest resolution time offered by host in milliseconds."}, NeverEquiv {:num-fields 0, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/NeverEquiv, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 6337, :record false, :end-line 6337, :tag function, :skip-protocol-flag #{cljs.core/IEquiv}}, chunkIteratorSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4142, :column 8, :end-line 4142, :end-column 24, :private true, :arglists (quote ([iter]))}, :private true, :name cljs.core/chunkIteratorSeq, :file "cljs/core.cljs", :end-column 24, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 4142, :ret-tag cljs.core/LazySeq, :end-line 4142, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter]))}, -invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 554, :column 4, :end-line 554, :end-column 11, :protocol cljs.core/IFn, :doc nil, :arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])), :top-fn {:variadic? false, :fixed-arity 22, :max-fixed-arity 22, :method-params [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]], :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}}, :protocol cljs.core/IFn, :name cljs.core/-invoke, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic? false, :fixed-arity 22, :max-fixed-arity 22, :method-params [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]], :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}, :method-params [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]], :protocol-impl nil, :fixed-arity 22, :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 1, :variadic? false, :tag any} {:fixed-arity 2, :variadic? false, :tag any} {:fixed-arity 3, :variadic? false, :tag any} {:fixed-arity 4, :variadic? false, :tag any} {:fixed-arity 5, :variadic? false, :tag any} {:fixed-arity 6, :variadic? false, :tag any} {:fixed-arity 7, :variadic? false, :tag any} {:fixed-arity 8, :variadic? false, :tag any} {:fixed-arity 9, :variadic? false, :tag any} {:fixed-arity 10, :variadic? false, :tag any} {:fixed-arity 11, :variadic? false, :tag any} {:fixed-arity 12, :variadic? false, :tag any} {:fixed-arity 13, :variadic? false, :tag any} {:fixed-arity 14, :variadic? false, :tag any} {:fixed-arity 15, :variadic? false, :tag any} {:fixed-arity 16, :variadic? false, :tag any} {:fixed-arity 17, :variadic? false, :tag any} {:fixed-arity 18, :variadic? false, :tag any} {:fixed-arity 19, :variadic? false, :tag any} {:fixed-arity 20, :variadic? false, :tag any} {:fixed-arity 21, :variadic? false, :tag any} {:fixed-arity 22, :variadic? false, :tag any}], :line 550, :end-line 554, :max-fixed-arity 22, :fn-var true, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :doc nil}, coll? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2133, :column 7, :end-line 2133, :end-column 12, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, :name cljs.core/coll?, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2133, :ret-tag boolean, :end-line 2133, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, get-in {:protocol-inline nil, :meta {:added "1.2", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[m ks] [m ks not-found]], :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :column 7, :line 5287, :end-line 5287, :arglists (quote ([m ks] [m ks not-found])), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, :added "1.2", :name cljs.core/get-in, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic? false, :fixed-arity 3, :max-fixed-arity 3, :method-params [[m ks] [m ks not-found]], :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :method-params [[m ks] [m ks not-found]], :protocol-impl nil, :fixed-arity 3, :arglists-meta (nil nil), :column 1, :variadic? false, :methods [{:fixed-arity 2, :variadic? false, :tag #{nil any}} {:fixed-arity 3, :variadic? false, :tag #{nil any}}], :line 5287, :end-line 5287, :max-fixed-arity 3, :fn-var true, :arglists ([m ks] [m ks not-found]), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, fnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1772, :column 7, :end-line 1772, :end-column 12, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/fnext, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1772, :ret-tag #{any clj-nil}, :end-line 1772, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, IList {:meta {:protocol-symbol true, :file "cljs/core.cljs", :end-column 19, :column 14, :line 735, :protocol-info {:methods {}}, :end-line 735, :sigs {}, :doc "Marker interface indicating a persistent list", :jsdoc ("@interface")}, :protocol-symbol true, :name cljs.core/IList, :file "cljs/core.cljs", :end-column 19, :column 1, :line 735, :protocol-info {:methods {}}, :info nil, :end-line 735, :tag any, :sigs {}, :impls #{cljs.core/Cons cljs.core/EmptyList cljs.core/List}, :doc "Marker interface indicating a persistent list", :jsdoc ("@interface")}, ArrayNodeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/ArrayNodeIterator, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7459, :record false, :end-line 7459, :tag function, :skip-protocol-flag nil}, List {:meta {:file "cljs/core.cljs", :line 1532, :column 45, :end-line 1532, :end-column 49, :declared true}, :num-fields 5, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/List, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 3052, :record false, :declared true, :end-line 3052, :tag function, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 661, :column 4, :end-line 661, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the value of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-val, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 657, :ret-tag any, :end-line 661, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the value of the map entry."}, bytes {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2833, :column 7, :end-line 2833, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/bytes, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 2833, :end-line 2833, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ObjMap {:protocol-inline nil, :meta {:protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :file "cljs/core.cljs", :end-column 16, :column 10, :factory :positional, :line 6412, :end-line 6412, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "Positional factory function for cljs.core/ObjMap."}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->ObjMap, :file "cljs/core.cljs", :end-column 16, :method-params ([meta keys strobj update-count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :factory :positional, :line 6412, :ret-tag cljs.core/ObjMap, :end-line 6412, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "Positional factory function for cljs.core/ObjMap."}, compare-symbols {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1059, :column 8, :end-line 1059, :end-column 23, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-symbols, :file "cljs/core.cljs", :end-column 23, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 1059, :ret-tag number, :end-line 1059, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 729, :column 16, :end-line 729, :end-column 20, :tag clj-or-nil, :protocol cljs.core/ISeqable, :doc "Returns a seq of o, or nil if o is empty.", :arglists (quote ([o]))}, :protocol cljs.core/ISeqable, :name cljs.core/-seq, :file "cljs/core.cljs", :end-column 20, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :variadic? false, :line 727, :ret-tag clj-or-nil, :end-line 729, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns a seq of o, or nil if o is empty."}}, :require-macros nil, :cljs.analyzer/constants {:seen #{form tag & uuid case* end defrecord* base obj fqn first try has-nil? rear hierarchy iter step boolean update-count method-table :ready chunk i rest :meta :dup comp dispatch-fn buffer :else left ns* :cljs.core/none shift iters xform :validator finally :default prefer-table loop* watches :ns :pending bitmap _seq nil-val v riter __hash meta _meta afn tree fn front buf next-entry :val key _next root-iter do vec :fallback-impl :keyword-fn :flush-on-newline default-dispatch-val :no-test validator letfn* if arr new :descendants ns completed :ancestors value name :readably :more-marker fields method-cache edit editable? base-count collision-hash deftype* let* start sourceIter coll not-native js* strobj _rest fn* val ascending? recur xf ci :status :print-length state :ok vals all :cljs.core/halt cached-hierarchy s :parents cnt node sym sb meta9712 seed prev-seed _hash keys meta11294 set! :tag tree-map . var :mutable quote root multi str next nodes seen hash-map catch :alt-impl ext-map-iter tail record mseq count :keywordize-keys current off stack transient-map prev len right throw fseq chunk-next :cljs.core/not-found more def f next-iter}, :order [:flush-on-newline :readably :meta :dup :print-length :else sb :default ns name str _hash :mutable _meta val sym s value iter _rest arr i meta ci afn first rest count __hash fqn fn buf end off chunk more meta9712 _seq _next vals iters buffer completed xf sourceIter multi state validator watches :validator all prev current next f prev-seed seed edit base v start cnt shift root tail vec node fseq riter front rear keys strobj update-count record base-count fields ext-map-iter key editable? :tag boolean len next-entry next-iter bitmap collision-hash nodes nil-val root-iter seen has-nil? stack ascending? left right comp tree mseq not-native :cljs.core/not-found hash-map transient-map tree-map step chunk-next :cljs.core/none :more-marker :alt-impl :fallback-impl :val :status :ready :pending :cljs.core/halt xform coll :keyword-fn :keywordize-keys :parents :descendants :ancestors dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy uuid & case* defrecord* try ns* finally loop* do letfn* if new deftype* let* js* fn* recur set! . var quote catch throw def :ok :no-test tag form :ns obj meta11294]}, :doc nil}